{"summary":{"failed":23,"p99":50.944000005722046,"total":37,"p95":28.31599998474121,"passed":14},"files":[{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\analysis\\\\test_analysis_core.jl\", 16, Some tests did not pass: 22 passed, 0 failed, 8 errored, 1 broken.)","ok":false,"file":"test_analysis_core.jl","seconds":23.999000072479248},{"error":null,"ok":true,"file":"test_graph_builder.jl","seconds":21.603000164031982},{"error":null,"ok":true,"file":"test_taint_propagation.jl","seconds":21.171000003814697},{"error":null,"ok":true,"file":"test_entity_clustering.jl","seconds":28.31599998474121},{"error":null,"ok":true,"file":"test_risk_engine.jl","seconds":20.243000030517578},{"error":null,"ok":true,"file":"test_explainability.jl","seconds":17.983999967575073},{"error":null,"ok":true,"file":"test_flow_attribution.jl","seconds":6.7799999713897705},{"error":null,"ok":true,"file":"test_influence_analysis.jl","seconds":10.20199990272522},{"error":null,"ok":true,"file":"test_f7_realtime_scoring.jl","seconds":7.883999824523926},{"error":null,"ok":true,"file":"test_analyze_wallet.jl","seconds":10.664999961853027},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\tools\\\\test_blacklist_checker.jl\", 31, Some tests did not pass: 44 passed, 0 failed, 1 errored, 0 broken.)","ok":false,"file":"test_blacklist_checker.jl","seconds":5.671000003814697},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\tools\\\\test_collaborative_filter.jl\", 19, ArgumentError(\"Package Clustering not found in current path.\\n- Run `import Pkg; Pkg.add(\\\"Clustering\\\")` to install the Clustering package.\"))","ok":false,"file":"test_collaborative_filter.jl","seconds":0.015000104904174805},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\tools\\\\test_detective_swarm.jl\", 31, Some tests did not pass: 45 passed, 0 failed, 2 errored, 0 broken.)","ok":false,"file":"test_detective_swarm.jl","seconds":3.321000099182129},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\tools\\\\test_pattern_matcher.jl\", 20, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\tools\\\\Tools.jl\", 1, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\tools\\\\core\\\\tool_example_adder.jl\", 3, UndefVarError(:CommonTypes, Main))))","ok":false,"file":"test_pattern_matcher.jl","seconds":1.809000015258789},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\tools\\\\test_risk_assessment.jl\", 42, Some tests did not pass: 56 passed, 0 failed, 1 errored, 0 broken.)","ok":false,"file":"test_risk_assessment.jl","seconds":11.675000190734863},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\tools\\\\test_shield_network.jl\", 20, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\tools\\\\Tools.jl\", 1, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\tools\\\\core\\\\tool_example_adder.jl\", 3, UndefVarError(:CommonTypes, Main))))","ok":false,"file":"test_shield_network.jl","seconds":2.0139999389648438},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\tools\\\\test_temporal_analysis.jl\", 20, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\tools\\\\Tools.jl\", 1, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\tools\\\\core\\\\tool_example_adder.jl\", 3, UndefVarError(:CommonTypes, Main))))","ok":false,"file":"test_temporal_analysis.jl","seconds":2.2360000610351562},{"error":null,"ok":true,"file":"test_dupin_agent.jl","seconds":6.618000030517578},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\agents\\\\test_marlowe_agent.jl\", 17, SystemError(\"opening file \\\"C:\\\\\\\\ghost-wallet-hunter\\\\\\\\juliaos\\\\\\\\core\\\\\\\\test\\\\\\\\unit\\\\\\\\agents\\\\\\\\test_marlowe_agent_fixed.jl\\\"\", 2, nothing))","ok":false,"file":"test_marlowe_agent.jl","seconds":0.01900005340576172},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\agents\\\\test_marple_agent.jl\", 433, Some tests did not pass: 35 passed, 2 failed, 1 errored, 0 broken.)","ok":false,"file":"test_marple_agent.jl","seconds":14.171000003814697},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\agents\\\\test_poirot_agent.jl\", 400, Some tests did not pass: 44 passed, 2 failed, 0 errored, 0 broken.)","ok":false,"file":"test_poirot_agent.jl","seconds":20.657999992370605},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\agents\\\\test_raven_agent.jl\", 22, SystemError(\"opening file \\\"C:\\\\\\\\ghost-wallet-hunter\\\\\\\\juliaos\\\\\\\\core\\\\\\\\src\\\\\\\\agents\\\\\\\\Agents.jl\\\"\", 2, nothing))","ok":false,"file":"test_raven_agent.jl","seconds":3.949000120162964},{"error":null,"ok":true,"file":"test_shadow_agent.jl","seconds":5.4100000858306885},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\agents\\\\test_spade_agent.jl\", 481, Some tests did not pass: 49 passed, 2 failed, 0 errored, 0 broken.)","ok":false,"file":"test_spade_agent.jl","seconds":21.79699993133545},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_authentication.jl\", 809, Some tests did not pass: 639 passed, 0 failed, 3 errored, 0 broken.)","ok":false,"file":"test_authentication.jl","seconds":2.7339999675750732},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_batch_processing.jl\", 366, Some tests did not pass: 53 passed, 14 failed, 2 errored, 0 broken.)","ok":false,"file":"test_batch_processing.jl","seconds":50.944000005722046},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_error_handling.jl\", 615, Some tests did not pass: 215 passed, 1 failed, 1 errored, 0 broken.)","ok":false,"file":"test_error_handling.jl","seconds":8.53600001335144},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_frontend_handlers.jl\", 19, ArgumentError(\"Package WebSockets not found in current path, maybe you meant `import/using .WebSockets`.\\n- Otherwise, run `import Pkg; Pkg.add(\\\"WebSockets\\\")` to install the WebSockets package.\"))","ok":false,"file":"test_frontend_handlers.jl","seconds":0.0280001163482666},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_metrics_handlers.jl\", 625, Base.Meta.ParseError(\"ParseError:\\n# Error @ C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_metrics_handlers.jl:625:56\\n    sorted_endpoints = sort(collect(endpoint_counts), by=x->x[2], rev=true)\\r\\n    return Dict(\\\"endpoint\\\" => ep, \\\"requests\\\" => count) for (ep, count) in sorted_endpoints[1:min(5, length(sorted_endpoints))]\\r\\n#                                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”€â”€ Expected `end`\", Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(\"# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\\r\\n# â•‘                    TEST_METRICS_HANDLERS.JL                                 â•‘\\r\\n# â•‘                                                                              â•‘\\r\\n# â•‘   Comprehensive Test Suite for Performance Metrics API Handlers             â•‘\\r\\n# â•‘   Part of Ghost Wallet Hunter - System Monitoring & Analytics               â•‘\\r\\n# â•‘                                                                              â•‘\\r\\n# â•‘   â€¢ Performance metrics collection and aggregation                          â•‘\\r\\n# â•‘   â€¢ System health monitoring and alerting                                   â•‘\\r\\n# â•‘   â€¢ Custom dashboard data preparation and export                            â•‘\\r\\n# â•‘   â€¢ Historical data analysis and trend identification                       â•‘\\r\\n# â•‘                                                                              â•‘\\r\\n# â•‘   Real Data Philosophy: 100% authentic system performance data              â•‘\\r\\n# â•‘   Performance Target: <100ms metrics collection, real-time updates         â•‘\\r\\n# â•‘   Scalability: 10k+ metrics/second, efficient aggregation, low overhead    â•‘\\r\\n# â•‘                                                                              â•‘\\r\\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n\\r\\nusing Test, JSON, Dates, HTTP, Base.Threads\\r\\nusing Statistics, DataStructures, UUIDs, LinearAlgebra\\r\\n\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n# METRICS HANDLER FIXTURES - PERFORMANCE DATA AND CONFIGURATIONS\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n\\r\\nconst METRIC_CATEGORIES = [\\r\\n    \\\"system_performance\\\",\\r\\n    \\\"api_response_times\\\",\\r\\n    \\\"blockchain_interactions\\\",\\r\\n    \\\"analysis_throughput\\\",\\r\\n    \\\"detective_agent_performance\\\",\\r\\n    \\\"user_activity\\\",\\r\\n    \\\"error_rates\\\",\\r\\n    \\\"resource_utilization\\\"\\r\\n]\\r\\n\\r\\nconst PERFORMANCE_THRESHOLDS = Dict(\\r\\n    \\\"api_response_time_ms\\\" => Dict(\\\"warning\\\" => 200, \\\"critical\\\" => 500),\\r\\n    \\\"analysis_completion_time_s\\\" => Dict(\\\"warning\\\" => 30, \\\"critical\\\" => 60),\\r\\n    \\\"memory_usage_percent\\\" => Dict(\\\"warning\\\" => 80, \\\"critical\\\" => 95),\\r\\n    \\\"cpu_usage_percent\\\" => Dict(\\\"warning\\\" => 70, \\\"critical\\\" => 90),\\r\\n    \\\"error_rate_percent\\\" => Dict(\\\"warning\\\" => 1, \\\"critical\\\" => 5),\\r\\n    \\\"blockchain_rpc_latency_ms\\\" => Dict(\\\"warning\\\" => 1000, \\\"critical\\\" => 3000),\\r\\n    \\\"success_rate_percent\\\" => Dict(\\\"warning\\\" => 95, \\\"critical\\\" => 90)\\r\\n)\\r\\n\\r\\nconst METRIC_AGGREGATION_PERIODS = [\\r\\n    \\\"1_minute\\\",\\r\\n    \\\"5_minutes\\\",\\r\\n    \\\"15_minutes\\\",\\r\\n    \\\"1_hour\\\",\\r\\n    \\\"6_hours\\\",\\r\\n    \\\"24_hours\\\",\\r\\n    \\\"7_days\\\"\\r\\n]\\r\\n\\r\\nconst DASHBOARD_WIDGETS = [\\r\\n    \\\"system_overview\\\",\\r\\n    \\\"api_performance\\\",\\r\\n    \\\"analysis_throughput\\\",\\r\\n    \\\"detective_agents_status\\\",\\r\\n    \\\"blockchain_health\\\",\\r\\n    \\\"user_activity\\\",\\r\\n    \\\"error_tracking\\\",\\r\\n    \\\"resource_utilization\\\"\\r\\n]\\r\\n\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n# METRICS COLLECTION INFRASTRUCTURE\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n\\r\\nmutable struct MetricsCollector\\r\\n    collector_id::String\\r\\n    start_time::DateTime\\r\\n    metrics_buffer::Dict{String, Vector{Dict{String, Any}}}\\r\\n    aggregated_metrics::Dict{String, Dict{String, Any}}\\r\\n    alert_history::Vector{Dict{String, Any}}\\r\\n    performance_baselines::Dict{String, Float64}\\r\\n    collection_frequency::Int  # seconds\\r\\n    buffer_size::Int\\r\\n    auto_cleanup::Bool\\r\\nend\\r\\n\\r\\nfunction MetricsCollector(collection_frequency::Int = 10)\\r\\n    return MetricsCollector(\\r\\n        \\\"collector_\\$(string(uuid4())[1:8])\\\",\\r\\n        now(),\\r\\n        Dict{String, Vector{Dict{String, Any}}}(),\\r\\n        Dict{String, Dict{String, Any}}(),\\r\\n        Dict{String, Any}[],\\r\\n        Dict{String, Float64}(),\\r\\n        collection_frequency,\\r\\n        10000,  # Max 10k metrics per category\\r\\n        true\\r\\n    )\\r\\nend\\r\\n\\r\\nmutable struct SystemMetrics\\r\\n    timestamp::DateTime\\r\\n    cpu_usage_percent::Float64\\r\\n    memory_usage_percent::Float64\\r\\n    disk_usage_percent::Float64\\r\\n    network_in_bytes::Int\\r\\n    network_out_bytes::Int\\r\\n    active_connections::Int\\r\\n    request_queue_size::Int\\r\\n    thread_pool_utilization::Float64\\r\\nend\\r\\n\\r\\nfunction SystemMetrics()\\r\\n    return SystemMetrics(\\r\\n        now(),\\r\\n        rand(5.0:80.0),      # Realistic CPU usage\\r\\n        rand(20.0:75.0),     # Realistic memory usage\\r\\n        rand(30.0:60.0),     # Realistic disk usage\\r\\n        rand(1000:50000),    # Network bytes in\\r\\n        rand(500:25000),     # Network bytes out\\r\\n        rand(10:200),        # Active connections\\r\\n        rand(0:50),          # Request queue\\r\\n        rand(0.1:0.9)        # Thread utilization\\r\\n    )\\r\\nend\\r\\n\\r\\nmutable struct APIMetrics\\r\\n    endpoint::String\\r\\n    method::String\\r\\n    response_time_ms::Float64\\r\\n    status_code::Int\\r\\n    response_size_bytes::Int\\r\\n    user_session_id::String\\r\\n    timestamp::DateTime\\r\\n    cached::Bool\\r\\n    rate_limited::Bool\\r\\nend\\r\\n\\r\\nfunction APIMetrics(endpoint::String, method::String = \\\"GET\\\")\\r\\n    return APIMetrics(\\r\\n        endpoint,\\r\\n        method,\\r\\n        rand(10.0:300.0),           # Response time 10-300ms\\r\\n        rand([200, 200, 200, 400, 500]),  # Mostly successful\\r\\n        rand(100:10000),            # Response size\\r\\n        \\\"session_\\$(rand(1000:9999))\\\",\\r\\n        now(),\\r\\n        rand() > 0.7,               # 30% cache hit rate\\r\\n        rand() > 0.95               # 5% rate limited\\r\\n    )\\r\\nend\\r\\n\\r\\nmutable struct AnalysisMetrics\\r\\n    analysis_id::String\\r\\n    analysis_type::String\\r\\n    wallet_count::Int\\r\\n    transaction_count::Int\\r\\n    processing_time_s::Float64\\r\\n    risk_score::Float64\\r\\n    patterns_detected::Int\\r\\n    detective_agents_used::Vector{String}\\r\\n    timestamp::DateTime\\r\\n    success::Bool\\r\\nend\\r\\n\\r\\nfunction AnalysisMetrics(analysis_type::String)\\r\\n    return AnalysisMetrics(\\r\\n        \\\"analysis_\\$(string(uuid4())[1:8])\\\",\\r\\n        analysis_type,\\r\\n        rand(1:50),                 # Wallets analyzed\\r\\n        rand(100:5000),             # Transactions processed\\r\\n        rand(1.0:45.0),             # Processing time\\r\\n        rand(0.1:0.9),              # Risk score\\r\\n        rand(0:10),                 # Patterns found\\r\\n        sample([\\\"poirot\\\", \\\"marple\\\", \\\"spade\\\", \\\"marlowe\\\"], rand(1:3)),\\r\\n        now(),\\r\\n        rand() > 0.05               # 95% success rate\\r\\n    )\\r\\nend\\r\\n\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n# METRICS COLLECTION AND AGGREGATION\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n\\r\\nfunction collect_system_metrics(collector::MetricsCollector)\\r\\n    \\\"\\\"\\\"Collect current system performance metrics\\\"\\\"\\\"\\r\\n\\r\\n    metrics = SystemMetrics()\\r\\n    metric_entry = Dict(\\r\\n        \\\"timestamp\\\" => metrics.timestamp,\\r\\n        \\\"cpu_usage\\\" => metrics.cpu_usage_percent,\\r\\n        \\\"memory_usage\\\" => metrics.memory_usage_percent,\\r\\n        \\\"disk_usage\\\" => metrics.disk_usage_percent,\\r\\n        \\\"network_in\\\" => metrics.network_in_bytes,\\r\\n        \\\"network_out\\\" => metrics.network_out_bytes,\\r\\n        \\\"active_connections\\\" => metrics.active_connections,\\r\\n        \\\"request_queue_size\\\" => metrics.request_queue_size,\\r\\n        \\\"thread_utilization\\\" => metrics.thread_pool_utilization\\r\\n    )\\r\\n\\r\\n    # Add to metrics buffer\\r\\n    if !haskey(collector.metrics_buffer, \\\"system_performance\\\")\\r\\n        collector.metrics_buffer[\\\"system_performance\\\"] = Dict{String, Any}[]\\r\\n    end\\r\\n\\r\\n    push!(collector.metrics_buffer[\\\"system_performance\\\"], metric_entry)\\r\\n\\r\\n    # Check for alerts\\r\\n    check_performance_alerts(collector, metric_entry)\\r\\n\\r\\n    return metric_entry\\r\\nend\\r\\n\\r\\nfunction collect_api_metrics(collector::MetricsCollector, endpoint::String, method::String = \\\"GET\\\")\\r\\n    \\\"\\\"\\\"Collect API endpoint performance metrics\\\"\\\"\\\"\\r\\n\\r\\n    api_metrics = APIMetrics(endpoint, method)\\r\\n    metric_entry = Dict(\\r\\n        \\\"timestamp\\\" => api_metrics.timestamp,\\r\\n        \\\"endpoint\\\" => api_metrics.endpoint,\\r\\n        \\\"method\\\" => api_metrics.method,\\r\\n        \\\"response_time_ms\\\" => api_metrics.response_time_ms,\\r\\n        \\\"status_code\\\" => api_metrics.status_code,\\r\\n        \\\"response_size\\\" => api_metrics.response_size_bytes,\\r\\n        \\\"session_id\\\" => api_metrics.user_session_id,\\r\\n        \\\"cached\\\" => api_metrics.cached,\\r\\n        \\\"rate_limited\\\" => api_metrics.rate_limited\\r\\n    )\\r\\n\\r\\n    # Add to metrics buffer\\r\\n    if !haskey(collector.metrics_buffer, \\\"api_response_times\\\")\\r\\n        collector.metrics_buffer[\\\"api_response_times\\\"] = Dict{String, Any}[]\\r\\n    end\\r\\n\\r\\n    push!(collector.metrics_buffer[\\\"api_response_times\\\"], metric_entry)\\r\\n\\r\\n    # Check API performance alerts\\r\\n    if api_metrics.response_time_ms > PERFORMANCE_THRESHOLDS[\\\"api_response_time_ms\\\"][\\\"warning\\\"]\\r\\n        generate_alert(collector, \\\"api_performance\\\", \\\"High API response time: \\$(api_metrics.response_time_ms)ms for \\$(endpoint)\\\")\\r\\n    end\\r\\n\\r\\n    return metric_entry\\r\\nend\\r\\n\\r\\nfunction collect_analysis_metrics(collector::MetricsCollector, analysis_type::String)\\r\\n    \\\"\\\"\\\"Collect blockchain analysis performance metrics\\\"\\\"\\\"\\r\\n\\r\\n    analysis_metrics = AnalysisMetrics(analysis_type)\\r\\n    metric_entry = Dict(\\r\\n        \\\"timestamp\\\" => analysis_metrics.timestamp,\\r\\n        \\\"analysis_id\\\" => analysis_metrics.analysis_id,\\r\\n        \\\"analysis_type\\\" => analysis_metrics.analysis_type,\\r\\n        \\\"wallet_count\\\" => analysis_metrics.wallet_count,\\r\\n        \\\"transaction_count\\\" => analysis_metrics.transaction_count,\\r\\n        \\\"processing_time_s\\\" => analysis_metrics.processing_time_s,\\r\\n        \\\"risk_score\\\" => analysis_metrics.risk_score,\\r\\n        \\\"patterns_detected\\\" => analysis_metrics.patterns_detected,\\r\\n        \\\"agents_used\\\" => analysis_metrics.detective_agents_used,\\r\\n        \\\"success\\\" => analysis_metrics.success\\r\\n    )\\r\\n\\r\\n    # Add to metrics buffer\\r\\n    if !haskey(collector.metrics_buffer, \\\"analysis_throughput\\\")\\r\\n        collector.metrics_buffer[\\\"analysis_throughput\\\"] = Dict{String, Any}[]\\r\\n    end\\r\\n\\r\\n    push!(collector.metrics_buffer[\\\"analysis_throughput\\\"], metric_entry)\\r\\n\\r\\n    # Check analysis performance alerts\\r\\n    if analysis_metrics.processing_time_s > PERFORMANCE_THRESHOLDS[\\\"analysis_completion_time_s\\\"][\\\"warning\\\"]\\r\\n        generate_alert(collector, \\\"analysis_performance\\\", \\\"Slow analysis: \\$(analysis_metrics.processing_time_s)s for \\$(analysis_type)\\\")\\r\\n    end\\r\\n\\r\\n    return metric_entry\\r\\nend\\r\\n\\r\\nfunction check_performance_alerts(collector::MetricsCollector, metrics::Dict{String, Any})\\r\\n    \\\"\\\"\\\"Check system metrics against performance thresholds and generate alerts\\\"\\\"\\\"\\r\\n\\r\\n    alerts_generated = 0\\r\\n\\r\\n    # Check CPU usage\\r\\n    if metrics[\\\"cpu_usage\\\"] > PERFORMANCE_THRESHOLDS[\\\"cpu_usage_percent\\\"][\\\"critical\\\"]\\r\\n        generate_alert(collector, \\\"system_critical\\\", \\\"Critical CPU usage: \\$(round(metrics[\\\"cpu_usage\\\"], digits=1))%\\\")\\r\\n        alerts_generated += 1\\r\\n    elseif metrics[\\\"cpu_usage\\\"] > PERFORMANCE_THRESHOLDS[\\\"cpu_usage_percent\\\"][\\\"warning\\\"]\\r\\n        generate_alert(collector, \\\"system_warning\\\", \\\"High CPU usage: \\$(round(metrics[\\\"cpu_usage\\\"], digits=1))%\\\")\\r\\n        alerts_generated += 1\\r\\n    end\\r\\n\\r\\n    # Check memory usage\\r\\n    if metrics[\\\"memory_usage\\\"] > PERFORMANCE_THRESHOLDS[\\\"memory_usage_percent\\\"][\\\"critical\\\"]\\r\\n        generate_alert(collector, \\\"system_critical\\\", \\\"Critical memory usage: \\$(round(metrics[\\\"memory_usage\\\"], digits=1))%\\\")\\r\\n        alerts_generated += 1\\r\\n    elseif metrics[\\\"memory_usage\\\"] > PERFORMANCE_THRESHOLDS[\\\"memory_usage_percent\\\"][\\\"warning\\\"]\\r\\n        generate_alert(collector, \\\"system_warning\\\", \\\"High memory usage: \\$(round(metrics[\\\"memory_usage\\\"], digits=1))%\\\")\\r\\n        alerts_generated += 1\\r\\n    end\\r\\n\\r\\n    return alerts_generated\\r\\nend\\r\\n\\r\\nfunction generate_alert(collector::MetricsCollector, severity::String, message::String)\\r\\n    \\\"\\\"\\\"Generate performance alert and add to alert history\\\"\\\"\\\"\\r\\n\\r\\n    alert = Dict(\\r\\n        \\\"alert_id\\\" => \\\"alert_\\$(string(uuid4())[1:8])\\\",\\r\\n        \\\"timestamp\\\" => now(),\\r\\n        \\\"severity\\\" => severity,\\r\\n        \\\"message\\\" => message,\\r\\n        \\\"acknowledged\\\" => false,\\r\\n        \\\"resolved\\\" => false\\r\\n    )\\r\\n\\r\\n    push!(collector.alert_history, alert)\\r\\n\\r\\n    # Keep only last 1000 alerts\\r\\n    if length(collector.alert_history) > 1000\\r\\n        collector.alert_history = collector.alert_history[end-999:end]\\r\\n    end\\r\\n\\r\\n    return alert\\r\\nend\\r\\n\\r\\nfunction aggregate_metrics(collector::MetricsCollector, category::String, period::String)\\r\\n    \\\"\\\"\\\"Aggregate metrics for specified category and time period\\\"\\\"\\\"\\r\\n\\r\\n    if !haskey(collector.metrics_buffer, category)\\r\\n        return Dict(\\\"error\\\" => \\\"Category not found\\\")\\r\\n    end\\r\\n\\r\\n    metrics_data = collector.metrics_buffer[category]\\r\\n    if isempty(metrics_data)\\r\\n        return Dict(\\\"error\\\" => \\\"No data available\\\")\\r\\n    end\\r\\n\\r\\n    # Calculate time window\\r\\n    current_time = now()\\r\\n    time_window = get_time_window(period)\\r\\n    cutoff_time = current_time - time_window\\r\\n\\r\\n    # Filter metrics within time window\\r\\n    filtered_metrics = filter(m -> m[\\\"timestamp\\\"] > cutoff_time, metrics_data)\\r\\n\\r\\n    if isempty(filtered_metrics)\\r\\n        return Dict(\\\"error\\\" => \\\"No data in time window\\\")\\r\\n    end\\r\\n\\r\\n    # Perform aggregation based on category\\r\\n    if category == \\\"system_performance\\\"\\r\\n        return aggregate_system_metrics(filtered_metrics)\\r\\n    elseif category == \\\"api_response_times\\\"\\r\\n        return aggregate_api_metrics(filtered_metrics)\\r\\n    elseif category == \\\"analysis_throughput\\\"\\r\\n        return aggregate_analysis_metrics(filtered_metrics)\\r\\n    else\\r\\n        return aggregate_generic_metrics(filtered_metrics)\\r\\n    end\\r\\nend\\r\\n\\r\\nfunction aggregate_system_metrics(metrics::Vector{Dict{String, Any}})\\r\\n    \\\"\\\"\\\"Aggregate system performance metrics\\\"\\\"\\\"\\r\\n\\r\\n    cpu_values = [m[\\\"cpu_usage\\\"] for m in metrics]\\r\\n    memory_values = [m[\\\"memory_usage\\\"] for m in metrics]\\r\\n\\r\\n    return Dict(\\r\\n        \\\"period_start\\\" => minimum(m[\\\"timestamp\\\"] for m in metrics),\\r\\n        \\\"period_end\\\" => maximum(m[\\\"timestamp\\\"] for m in metrics),\\r\\n        \\\"data_points\\\" => length(metrics),\\r\\n        \\\"cpu_usage\\\" => Dict(\\r\\n            \\\"avg\\\" => mean(cpu_values),\\r\\n            \\\"min\\\" => minimum(cpu_values),\\r\\n            \\\"max\\\" => maximum(cpu_values),\\r\\n            \\\"p95\\\" => quantile(cpu_values, 0.95)\\r\\n        ),\\r\\n        \\\"memory_usage\\\" => Dict(\\r\\n            \\\"avg\\\" => mean(memory_values),\\r\\n            \\\"min\\\" => minimum(memory_values),\\r\\n            \\\"max\\\" => maximum(memory_values),\\r\\n            \\\"p95\\\" => quantile(memory_values, 0.95)\\r\\n        ),\\r\\n        \\\"active_connections\\\" => Dict(\\r\\n            \\\"avg\\\" => mean([m[\\\"active_connections\\\"] for m in metrics]),\\r\\n            \\\"max\\\" => maximum([m[\\\"active_connections\\\"] for m in metrics])\\r\\n        )\\r\\n    )\\r\\nend\\r\\n\\r\\nfunction aggregate_api_metrics(metrics::Vector{Dict{String, Any}})\\r\\n    \\\"\\\"\\\"Aggregate API performance metrics\\\"\\\"\\\"\\r\\n\\r\\n    response_times = [m[\\\"response_time_ms\\\"] for m in metrics]\\r\\n    success_count = sum(m[\\\"status_code\\\"] < 400 for m in metrics)\\r\\n\\r\\n    # Group by endpoint\\r\\n    endpoint_stats = Dict{String, Dict{String, Any}}()\\r\\n    for metric in metrics\\r\\n        endpoint = metric[\\\"endpoint\\\"]\\r\\n        if !haskey(endpoint_stats, endpoint)\\r\\n            endpoint_stats[endpoint] = Dict{String, Any}[]\\r\\n        end\\r\\n        push!(endpoint_stats[endpoint], metric)\\r\\n    end\\r\\n\\r\\n    return Dict(\\r\\n        \\\"period_start\\\" => minimum(m[\\\"timestamp\\\"] for m in metrics),\\r\\n        \\\"period_end\\\" => maximum(m[\\\"timestamp\\\"] for m in metrics),\\r\\n        \\\"total_requests\\\" => length(metrics),\\r\\n        \\\"success_rate\\\" => success_count / length(metrics),\\r\\n        \\\"response_time_ms\\\" => Dict(\\r\\n            \\\"avg\\\" => mean(response_times),\\r\\n            \\\"min\\\" => minimum(response_times),\\r\\n            \\\"max\\\" => maximum(response_times),\\r\\n            \\\"p50\\\" => quantile(response_times, 0.5),\\r\\n            \\\"p95\\\" => quantile(response_times, 0.95),\\r\\n            \\\"p99\\\" => quantile(response_times, 0.99)\\r\\n        ),\\r\\n        \\\"endpoint_breakdown\\\" => Dict(\\r\\n            endpoint => Dict(\\r\\n                \\\"request_count\\\" => length(stats),\\r\\n                \\\"avg_response_time\\\" => mean([s[\\\"response_time_ms\\\"] for s in stats]),\\r\\n                \\\"success_rate\\\" => sum(s[\\\"status_code\\\"] < 400 for s in stats) / length(stats)\\r\\n            ) for (endpoint, stats) in endpoint_stats\\r\\n        ),\\r\\n        \\\"cache_hit_rate\\\" => sum(m[\\\"cached\\\"] for m in metrics) / length(metrics),\\r\\n        \\\"rate_limit_percentage\\\" => sum(m[\\\"rate_limited\\\"] for m in metrics) / length(metrics) * 100\\r\\n    )\\r\\nend\\r\\n\\r\\nfunction aggregate_analysis_metrics(metrics::Vector{Dict{String, Any}})\\r\\n    \\\"\\\"\\\"Aggregate blockchain analysis performance metrics\\\"\\\"\\\"\\r\\n\\r\\n    processing_times = [m[\\\"processing_time_s\\\"] for m in metrics]\\r\\n    successful_analyses = sum(m[\\\"success\\\"] for m in metrics)\\r\\n\\r\\n    return Dict(\\r\\n        \\\"period_start\\\" => minimum(m[\\\"timestamp\\\"] for m in metrics),\\r\\n        \\\"period_end\\\" => maximum(m[\\\"timestamp\\\"] for m in metrics),\\r\\n        \\\"total_analyses\\\" => length(metrics),\\r\\n        \\\"success_rate\\\" => successful_analyses / length(metrics),\\r\\n        \\\"processing_time_s\\\" => Dict(\\r\\n            \\\"avg\\\" => mean(processing_times),\\r\\n            \\\"min\\\" => minimum(processing_times),\\r\\n            \\\"max\\\" => maximum(processing_times),\\r\\n            \\\"p95\\\" => quantile(processing_times, 0.95)\\r\\n        ),\\r\\n        \\\"throughput\\\" => Dict(\\r\\n            \\\"total_wallets\\\" => sum(m[\\\"wallet_count\\\"] for m in metrics),\\r\\n            \\\"total_transactions\\\" => sum(m[\\\"transaction_count\\\"] for m in metrics),\\r\\n            \\\"avg_wallets_per_analysis\\\" => mean([m[\\\"wallet_count\\\"] for m in metrics]),\\r\\n            \\\"avg_transactions_per_analysis\\\" => mean([m[\\\"transaction_count\\\"] for m in metrics])\\r\\n        ),\\r\\n        \\\"risk_analysis\\\" => Dict(\\r\\n            \\\"avg_risk_score\\\" => mean([m[\\\"risk_score\\\"] for m in metrics]),\\r\\n            \\\"avg_patterns_detected\\\" => mean([m[\\\"patterns_detected\\\"] for m in metrics])\\r\\n        ),\\r\\n        \\\"agent_usage\\\" => count_agent_usage(metrics)\\r\\n    )\\r\\nend\\r\\n\\r\\nfunction count_agent_usage(metrics::Vector{Dict{String, Any}})\\r\\n    \\\"\\\"\\\"Count detective agent usage statistics\\\"\\\"\\\"\\r\\n\\r\\n    agent_counts = Dict{String, Int}()\\r\\n\\r\\n    for metric in metrics\\r\\n        for agent in metric[\\\"agents_used\\\"]\\r\\n            agent_counts[agent] = get(agent_counts, agent, 0) + 1\\r\\n        end\\r\\n    end\\r\\n\\r\\n    return agent_counts\\r\\nend\\r\\n\\r\\nfunction get_time_window(period::String)\\r\\n    \\\"\\\"\\\"Convert period string to DateTime duration\\\"\\\"\\\"\\r\\n\\r\\n    if period == \\\"1_minute\\\"\\r\\n        return Minute(1)\\r\\n    elseif period == \\\"5_minutes\\\"\\r\\n        return Minute(5)\\r\\n    elseif period == \\\"15_minutes\\\"\\r\\n        return Minute(15)\\r\\n    elseif period == \\\"1_hour\\\"\\r\\n        return Hour(1)\\r\\n    elseif period == \\\"6_hours\\\"\\r\\n        return Hour(6)\\r\\n    elseif period == \\\"24_hours\\\"\\r\\n        return Hour(24)\\r\\n    elseif period == \\\"7_days\\\"\\r\\n        return Day(7)\\r\\n    else\\r\\n        return Hour(1)  # Default to 1 hour\\r\\n    end\\r\\nend\\r\\n\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n# DASHBOARD DATA PREPARATION\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n\\r\\nfunction prepare_dashboard_data(collector::MetricsCollector)\\r\\n    \\\"\\\"\\\"Prepare comprehensive dashboard data for frontend\\\"\\\"\\\"\\r\\n\\r\\n    current_time = now()\\r\\n\\r\\n    # Collect fresh metrics\\r\\n    fresh_system_metrics = collect_system_metrics(collector)\\r\\n\\r\\n    # Get aggregated data for different time periods\\r\\n    hourly_system = aggregate_metrics(collector, \\\"system_performance\\\", \\\"1_hour\\\")\\r\\n    hourly_api = aggregate_metrics(collector, \\\"api_response_times\\\", \\\"1_hour\\\")\\r\\n    hourly_analysis = aggregate_metrics(collector, \\\"analysis_throughput\\\", \\\"1_hour\\\")\\r\\n\\r\\n    # Prepare widget data\\r\\n    dashboard_data = Dict(\\r\\n        \\\"timestamp\\\" => current_time,\\r\\n        \\\"widgets\\\" => Dict(\\r\\n            \\\"system_overview\\\" => Dict(\\r\\n                \\\"status\\\" => determine_system_status(fresh_system_metrics),\\r\\n                \\\"uptime_hours\\\" => (current_time - collector.start_time).value / (1000 * 3600),\\r\\n                \\\"current_metrics\\\" => fresh_system_metrics,\\r\\n                \\\"alerts_count\\\" => length([a for a in collector.alert_history if !a[\\\"acknowledged\\\"]])\\r\\n            ),\\r\\n            \\\"api_performance\\\" => Dict(\\r\\n                \\\"status\\\" => determine_api_status(hourly_api),\\r\\n                \\\"hourly_stats\\\" => hourly_api,\\r\\n                \\\"top_endpoints\\\" => get_top_endpoints(collector),\\r\\n                \\\"error_rate\\\" => calculate_error_rate(collector)\\r\\n            ),\\r\\n            \\\"analysis_throughput\\\" => Dict(\\r\\n                \\\"status\\\" => determine_analysis_status(hourly_analysis),\\r\\n                \\\"hourly_stats\\\" => hourly_analysis,\\r\\n                \\\"active_analyses\\\" => count_active_analyses(collector),\\r\\n                \\\"success_rate\\\" => get_analysis_success_rate(collector)\\r\\n            ),\\r\\n            \\\"detective_agents_status\\\" => Dict(\\r\\n                \\\"agents_active\\\" => [\\\"poirot\\\", \\\"marple\\\", \\\"spade\\\", \\\"marlowe\\\"],\\r\\n                \\\"usage_stats\\\" => get_agent_usage_stats(collector),\\r\\n                \\\"performance\\\" => get_agent_performance_stats(collector)\\r\\n            ),\\r\\n            \\\"blockchain_health\\\" => Dict(\\r\\n                \\\"rpc_status\\\" => \\\"operational\\\",\\r\\n                \\\"avg_latency_ms\\\" => rand(100:300),\\r\\n                \\\"success_rate\\\" => rand(0.95:0.01:0.99),\\r\\n                \\\"rate_limit_status\\\" => \\\"within_limits\\\"\\r\\n            ),\\r\\n            \\\"user_activity\\\" => Dict(\\r\\n                \\\"active_sessions\\\" => rand(10:100),\\r\\n                \\\"requests_per_hour\\\" => rand(500:2000),\\r\\n                \\\"unique_users_today\\\" => rand(20:150)\\r\\n            ),\\r\\n            \\\"error_tracking\\\" => Dict(\\r\\n                \\\"errors_last_hour\\\" => length(get_recent_errors(collector, Hour(1))),\\r\\n                \\\"error_rate\\\" => calculate_error_rate(collector),\\r\\n                \\\"top_errors\\\" => get_top_errors(collector)\\r\\n            ),\\r\\n            \\\"resource_utilization\\\" => Dict(\\r\\n                \\\"cpu_trend\\\" => get_cpu_trend(collector),\\r\\n                \\\"memory_trend\\\" => get_memory_trend(collector),\\r\\n                \\\"network_io\\\" => get_network_stats(collector)\\r\\n            )\\r\\n        ),\\r\\n        \\\"refresh_timestamp\\\" => current_time\\r\\n    )\\r\\n\\r\\n    return dashboard_data\\r\\nend\\r\\n\\r\\nfunction determine_system_status(metrics::Dict{String, Any})\\r\\n    \\\"\\\"\\\"Determine overall system status based on current metrics\\\"\\\"\\\"\\r\\n\\r\\n    cpu = metrics[\\\"cpu_usage\\\"]\\r\\n    memory = metrics[\\\"memory_usage\\\"]\\r\\n\\r\\n    if cpu > PERFORMANCE_THRESHOLDS[\\\"cpu_usage_percent\\\"][\\\"critical\\\"] ||\\r\\n       memory > PERFORMANCE_THRESHOLDS[\\\"memory_usage_percent\\\"][\\\"critical\\\"]\\r\\n        return \\\"critical\\\"\\r\\n    elseif cpu > PERFORMANCE_THRESHOLDS[\\\"cpu_usage_percent\\\"][\\\"warning\\\"] ||\\r\\n           memory > PERFORMANCE_THRESHOLDS[\\\"memory_usage_percent\\\"][\\\"warning\\\"]\\r\\n        return \\\"warning\\\"\\r\\n    else\\r\\n        return \\\"healthy\\\"\\r\\n    end\\r\\nend\\r\\n\\r\\nfunction determine_api_status(api_metrics::Dict)\\r\\n    \\\"\\\"\\\"Determine API performance status\\\"\\\"\\\"\\r\\n\\r\\n    if haskey(api_metrics, \\\"error\\\") || !haskey(api_metrics, \\\"response_time_ms\\\")\\r\\n        return \\\"unknown\\\"\\r\\n    end\\r\\n\\r\\n    avg_response_time = api_metrics[\\\"response_time_ms\\\"][\\\"avg\\\"]\\r\\n    success_rate = api_metrics[\\\"success_rate\\\"]\\r\\n\\r\\n    if avg_response_time > PERFORMANCE_THRESHOLDS[\\\"api_response_time_ms\\\"][\\\"critical\\\"] ||\\r\\n       success_rate < (PERFORMANCE_THRESHOLDS[\\\"success_rate_percent\\\"][\\\"critical\\\"] / 100)\\r\\n        return \\\"critical\\\"\\r\\n    elseif avg_response_time > PERFORMANCE_THRESHOLDS[\\\"api_response_time_ms\\\"][\\\"warning\\\"] ||\\r\\n           success_rate < (PERFORMANCE_THRESHOLDS[\\\"success_rate_percent\\\"][\\\"warning\\\"] / 100)\\r\\n        return \\\"warning\\\"\\r\\n    else\\r\\n        return \\\"healthy\\\"\\r\\n    end\\r\\nend\\r\\n\\r\\nfunction get_top_endpoints(collector::MetricsCollector)\\r\\n    \\\"\\\"\\\"Get top API endpoints by request volume\\\"\\\"\\\"\\r\\n\\r\\n    if !haskey(collector.metrics_buffer, \\\"api_response_times\\\")\\r\\n        return []\\r\\n    end\\r\\n\\r\\n    metrics = collector.metrics_buffer[\\\"api_response_times\\\"]\\r\\n    endpoint_counts = Dict{String, Int}()\\r\\n\\r\\n    # Count requests per endpoint (last hour)\\r\\n    cutoff_time = now() - Hour(1)\\r\\n    recent_metrics = filter(m -> m[\\\"timestamp\\\"] > cutoff_time, metrics)\\r\\n\\r\\n    for metric in recent_metrics\\r\\n        endpoint = metric[\\\"endpoint\\\"]\\r\\n        endpoint_counts[endpoint] = get(endpoint_counts, endpoint, 0) + 1\\r\\n    end\\r\\n\\r\\n    # Sort by count and return top 5\\r\\n    sorted_endpoints = sort(collect(endpoint_counts), by=x->x[2], rev=true)\\r\\n    return Dict(\\\"endpoint\\\" => ep, \\\"requests\\\" => count) for (ep, count) in sorted_endpoints[1:min(5, length(sorted_endpoints))]\\r\\nend\\r\\n\\r\\nfunction calculate_error_rate(collector::MetricsCollector)\\r\\n    \\\"\\\"\\\"Calculate current error rate percentage\\\"\\\"\\\"\\r\\n\\r\\n    if !haskey(collector.metrics_buffer, \\\"api_response_times\\\")\\r\\n        return 0.0\\r\\n    end\\r\\n\\r\\n    # Calculate for last hour\\r\\n    cutoff_time = now() - Hour(1)\\r\\n    recent_metrics = filter(m -> m[\\\"timestamp\\\"] > cutoff_time, collector.metrics_buffer[\\\"api_response_times\\\"])\\r\\n\\r\\n    if isempty(recent_metrics)\\r\\n        return 0.0\\r\\n    end\\r\\n\\r\\n    error_count = sum(m[\\\"status_code\\\"] >= 400 for m in recent_metrics)\\r\\n    return (error_count / length(recent_metrics)) * 100\\r\\nend\\r\\n\\r\\nfunction get_agent_usage_stats(collector::MetricsCollector)\\r\\n    \\\"\\\"\\\"Get detective agent usage statistics\\\"\\\"\\\"\\r\\n\\r\\n    if !haskey(collector.metrics_buffer, \\\"analysis_throughput\\\")\\r\\n        return Dict()\\r\\n    end\\r\\n\\r\\n    # Calculate for last 24 hours\\r\\n    cutoff_time = now() - Hour(24)\\r\\n    recent_analyses = filter(m -> m[\\\"timestamp\\\"] > cutoff_time, collector.metrics_buffer[\\\"analysis_throughput\\\"])\\r\\n\\r\\n    agent_stats = Dict{String, Dict{String, Any}}()\\r\\n\\r\\n    for analysis in recent_analyses\\r\\n        for agent in analysis[\\\"agents_used\\\"]\\r\\n            if !haskey(agent_stats, agent)\\r\\n                agent_stats[agent] = Dict(\\\"usage_count\\\" => 0, \\\"total_processing_time\\\" => 0.0)\\r\\n            end\\r\\n            agent_stats[agent][\\\"usage_count\\\"] += 1\\r\\n            agent_stats[agent][\\\"total_processing_time\\\"] += analysis[\\\"processing_time_s\\\"]\\r\\n        end\\r\\n    end\\r\\n\\r\\n    # Calculate averages\\r\\n    for (agent, stats) in agent_stats\\r\\n        if stats[\\\"usage_count\\\"] > 0\\r\\n            stats[\\\"avg_processing_time\\\"] = stats[\\\"total_processing_time\\\"] / stats[\\\"usage_count\\\"]\\r\\n        end\\r\\n    end\\r\\n\\r\\n    return agent_stats\\r\\nend\\r\\n\\r\\nfunction export_metrics_data(collector::MetricsCollector, format::String = \\\"json\\\", time_range::String = \\\"24_hours\\\")\\r\\n    \\\"\\\"\\\"Export metrics data in specified format\\\"\\\"\\\"\\r\\n\\r\\n    export_data = Dict(\\r\\n        \\\"export_timestamp\\\" => now(),\\r\\n        \\\"time_range\\\" => time_range,\\r\\n        \\\"format\\\" => format,\\r\\n        \\\"collector_info\\\" => Dict(\\r\\n            \\\"collector_id\\\" => collector.collector_id,\\r\\n            \\\"start_time\\\" => collector.start_time,\\r\\n            \\\"collection_frequency\\\" => collector.collection_frequency\\r\\n        ),\\r\\n        \\\"metrics_summary\\\" => Dict(\\r\\n            \\\"total_categories\\\" => length(collector.metrics_buffer),\\r\\n            \\\"total_data_points\\\" => sum(length(v) for v in values(collector.metrics_buffer)),\\r\\n            \\\"alert_count\\\" => length(collector.alert_history)\\r\\n        ),\\r\\n        \\\"aggregated_data\\\" => Dict()\\r\\n    )\\r\\n\\r\\n    # Add aggregated data for each category\\r\\n    for category in keys(collector.metrics_buffer)\\r\\n        export_data[\\\"aggregated_data\\\"][category] = aggregate_metrics(collector, category, time_range)\\r\\n    end\\r\\n\\r\\n    # Add recent alerts\\r\\n    export_data[\\\"recent_alerts\\\"] = collector.alert_history[max(1, end-19):end]  # Last 20 alerts\\r\\n\\r\\n    return export_data\\r\\nend\\r\\n\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n# MAIN TEST SUITE - METRICS HANDLERS\\r\\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\r\\n\\r\\n@testset \\\"ğŸ“Š Metrics Handlers - Performance Monitoring & Analytics\\\" begin\\r\\n    println(\\\"\\\\n\\\" * \\\"=\\\"^80)\\r\\n    println(\\\"ğŸ“Š METRICS HANDLERS - COMPREHENSIVE VALIDATION\\\")\\r\\n    println(\\\"=\\\"^80)\\r\\n\\r\\n    @testset \\\"Metrics Collection and Storage\\\" begin\\r\\n        println(\\\"\\\\nğŸ“ˆ Testing metrics collection and storage mechanisms...\\\")\\r\\n\\r\\n        collection_start = time()\\r\\n\\r\\n        collector = MetricsCollector(5)  # 5-second collection frequency\\r\\n\\r\\n        @test collector.collector_id !== nothing\\r\\n        @test collector.collection_frequency == 5\\r\\n        @test collector.auto_cleanup == true\\r\\n        @test length(collector.metrics_buffer) == 0\\r\\n\\r\\n        # Test system metrics collection\\r\\n        system_metric = collect_system_metrics(collector)\\r\\n\\r\\n        @test haskey(system_metric, \\\"timestamp\\\")\\r\\n        @test haskey(system_metric, \\\"cpu_usage\\\")\\r\\n        @test haskey(system_metric, \\\"memory_usage\\\")\\r\\n        @test haskey(system_metric, \\\"active_connections\\\")\\r\\n        @test 0.0 <= system_metric[\\\"cpu_usage\\\"] <= 100.0\\r\\n        @test 0.0 <= system_metric[\\\"memory_usage\\\"] <= 100.0\\r\\n        @test system_metric[\\\"active_connections\\\"] >= 0\\r\\n\\r\\n        @test haskey(collector.metrics_buffer, \\\"system_performance\\\")\\r\\n        @test length(collector.metrics_buffer[\\\"system_performance\\\"]) == 1\\r\\n\\r\\n        # Test API metrics collection\\r\\n        api_endpoints = [\\r\\n            \\\"/api/v1/wallet/analyze\\\",\\r\\n            \\\"/api/v1/pattern/detect\\\",\\r\\n            \\\"/api/v1/monitoring/status\\\"\\r\\n        ]\\r\\n\\r\\n        for endpoint in api_endpoints\\r\\n            api_metric = collect_api_metrics(collector, endpoint)\\r\\n\\r\\n            @test haskey(api_metric, \\\"endpoint\\\")\\r\\n            @test haskey(api_metric, \\\"response_time_ms\\\")\\r\\n            @test haskey(api_metric, \\\"status_code\\\")\\r\\n            @test api_metric[\\\"endpoint\\\"] == endpoint\\r\\n            @test api_metric[\\\"response_time_ms\\\"] > 0.0\\r\\n            @test api_metric[\\\"status_code\\\"] in [200, 400, 500]\\r\\n        end\\r\\n\\r\\n        @test haskey(collector.metrics_buffer, \\\"api_response_times\\\")\\r\\n        @test length(collector.metrics_buffer[\\\"api_response_times\\\"]) == length(api_endpoints)\\r\\n\\r\\n        # Test analysis metrics collection\\r\\n        analysis_types = [\\\"wallet_investigation\\\", \\\"pattern_detection\\\", \\\"risk_assessment\\\"]\\r\\n\\r\\n        for analysis_type in analysis_types\\r\\n            analysis_metric = collect_analysis_metrics(collector, analysis_type)\\r\\n\\r\\n            @test haskey(analysis_metric, \\\"analysis_type\\\")\\r\\n            @test haskey(analysis_metric, \\\"processing_time_s\\\")\\r\\n            @test haskey(analysis_metric, \\\"success\\\")\\r\\n            @test analysis_metric[\\\"analysis_type\\\"] == analysis_type\\r\\n            @test analysis_metric[\\\"processing_time_s\\\"] > 0.0\\r\\n            @test typeof(analysis_metric[\\\"success\\\"]) == Bool\\r\\n        end\\r\\n\\r\\n        @test haskey(collector.metrics_buffer, \\\"analysis_throughput\\\")\\r\\n        @test length(collector.metrics_buffer[\\\"analysis_throughput\\\"]) == length(analysis_types)\\r\\n\\r\\n        collection_time = time() - collection_start\\r\\n        @test collection_time < 2.0  # Collection should be fast\\r\\n\\r\\n        println(\\\"âœ… Metrics collection validated\\\")\\r\\n        println(\\\"ğŸ“Š System metrics: \\$(length(collector.metrics_buffer[\\\"system_performance\\\"])) entries\\\")\\r\\n        println(\\\"ğŸ“Š API metrics: \\$(length(collector.metrics_buffer[\\\"api_response_times\\\"])) entries\\\")\\r\\n        println(\\\"ğŸ“Š Analysis metrics: \\$(length(collector.metrics_buffer[\\\"analysis_throughput\\\"])) entries\\\")\\r\\n        println(\\\"âš¡ Collection time: \\$(round(collection_time, digits=3))s\\\")\\r\\n    end\\r\\n\\r\\n    @testset \\\"Performance Alert Generation and Monitoring\\\" begin\\r\\n        println(\\\"\\\\nğŸš¨ Testing performance alert generation and monitoring...\\\")\\r\\n\\r\\n        alert_start = time()\\r\\n\\r\\n        collector = MetricsCollector()\\r\\n\\r\\n        # Test normal metrics (no alerts)\\r\\n        normal_metrics = Dict(\\r\\n            \\\"timestamp\\\" => now(),\\r\\n            \\\"cpu_usage\\\" => 30.0,\\r\\n            \\\"memory_usage\\\" => 45.0,\\r\\n            \\\"disk_usage\\\" => 40.0\\r\\n        )\\r\\n\\r\\n        initial_alert_count = length(collector.alert_history)\\r\\n        alerts_generated = check_performance_alerts(collector, normal_metrics)\\r\\n\\r\\n        @test alerts_generated == 0\\r\\n        @test length(collector.alert_history) == initial_alert_count\\r\\n\\r\\n        # Test warning threshold metrics\\r\\n        warning_metrics = Dict(\\r\\n            \\\"timestamp\\\" => now(),\\r\\n            \\\"cpu_usage\\\" => 75.0,  # Above warning threshold (70%)\\r\\n            \\\"memory_usage\\\" => 85.0,  # Above warning threshold (80%)\\r\\n            \\\"disk_usage\\\" => 50.0\\r\\n        )\\r\\n\\r\\n        warning_alerts = check_performance_alerts(collector, warning_metrics)\\r\\n\\r\\n        @test warning_alerts == 2  # CPU and memory warnings\\r\\n        @test length(collector.alert_history) > initial_alert_count\\r\\n\\r\\n        # Verify alert structure\\r\\n        recent_alerts = collector.alert_history[end-1:end]\\r\\n        for alert in recent_alerts\\r\\n            @test haskey(alert, \\\"alert_id\\\")\\r\\n            @test haskey(alert, \\\"timestamp\\\")\\r\\n            @test haskey(alert, \\\"severity\\\")\\r\\n            @test haskey(alert, \\\"message\\\")\\r\\n            @test alert[\\\"severity\\\"] == \\\"system_warning\\\"\\r\\n            @test !alert[\\\"acknowledged\\\"]\\r\\n            @test !alert[\\\"resolved\\\"]\\r\\n        end\\r\\n\\r\\n        # Test critical threshold metrics\\r\\n        critical_metrics = Dict(\\r\\n            \\\"timestamp\\\" => now(),\\r\\n            \\\"cpu_usage\\\" => 95.0,  # Above critical threshold (90%)\\r\\n            \\\"memory_usage\\\" => 98.0,  # Above critical threshold (95%)\\r\\n            \\\"disk_usage\\\" => 60.0\\r\\n        )\\r\\n\\r\\n        critical_alerts = check_performance_alerts(collector, critical_metrics)\\r\\n\\r\\n        @test critical_alerts == 2  # CPU and memory critical alerts\\r\\n\\r\\n        # Test API response time alerts\\r\\n        slow_api_metric = collect_api_metrics(collector, \\\"/api/v1/slow/endpoint\\\")\\r\\n        # Manually set slow response time\\r\\n        slow_metric_data = collector.metrics_buffer[\\\"api_response_times\\\"][end]\\r\\n        slow_metric_data[\\\"response_time_ms\\\"] = 600.0  # Above critical threshold\\r\\n\\r\\n        # This should trigger an alert during collection\\r\\n        alert_count_before = length(collector.alert_history)\\r\\n        collect_api_metrics(collector, \\\"/api/v1/another/slow/endpoint\\\")\\r\\n\\r\\n        # Manually trigger alert for testing\\r\\n        if slow_metric_data[\\\"response_time_ms\\\"] > PERFORMANCE_THRESHOLDS[\\\"api_response_time_ms\\\"][\\\"warning\\\"]\\r\\n            generate_alert(collector, \\\"api_performance\\\", \\\"Test slow API response\\\")\\r\\n        end\\r\\n\\r\\n        @test length(collector.alert_history) > alert_count_before\\r\\n\\r\\n        alert_time = time() - alert_start\\r\\n        @test alert_time < 1.0  # Alert generation should be very fast\\r\\n\\r\\n        println(\\\"âœ… Performance alerts validated\\\")\\r\\n        println(\\\"ğŸ“Š Total alerts generated: \\$(length(collector.alert_history))\\\")\\r\\n        println(\\\"ğŸ“Š Warning alerts: \\$(warning_alerts)\\\")\\r\\n        println(\\\"ğŸ“Š Critical alerts: \\$(critical_alerts)\\\")\\r\\n        println(\\\"âš¡ Alert processing: \\$(round(alert_time, digits=3))s\\\")\\r\\n    end\\r\\n\\r\\n    @testset \\\"Metrics Aggregation and Analysis\\\" begin\\r\\n        println(\\\"\\\\nğŸ“ˆ Testing metrics aggregation and statistical analysis...\\\")\\r\\n\\r\\n        aggregation_start = time()\\r\\n\\r\\n        collector = MetricsCollector()\\r\\n\\r\\n        # Generate substantial dataset for aggregation\\r\\n        for i in 1:50\\r\\n            collect_system_metrics(collector)\\r\\n            collect_api_metrics(collector, \\\"/api/v1/test/endpoint\\\")\\r\\n            collect_analysis_metrics(collector, \\\"test_analysis\\\")\\r\\n\\r\\n            # Small delay to simulate time progression\\r\\n            sleep(0.01)\\r\\n        end\\r\\n\\r\\n        @test length(collector.metrics_buffer[\\\"system_performance\\\"]) == 50\\r\\n        @test length(collector.metrics_buffer[\\\"api_response_times\\\"]) == 50\\r\\n        @test length(collector.metrics_buffer[\\\"analysis_throughput\\\"]) == 50\\r\\n\\r\\n        # Test system metrics aggregation\\r\\n        system_aggregation = aggregate_metrics(collector, \\\"system_performance\\\", \\\"1_hour\\\")\\r\\n\\r\\n        @test !haskey(system_aggregation, \\\"error\\\")\\r\\n        @test haskey(system_aggregation, \\\"data_points\\\")\\r\\n        @test haskey(system_aggregation, \\\"cpu_usage\\\")\\r\\n        @test haskey(system_aggregation, \\\"memory_usage\\\")\\r\\n        @test system_aggregation[\\\"data_points\\\"] == 50\\r\\n\\r\\n        cpu_stats = system_aggregation[\\\"cpu_usage\\\"]\\r\\n        @test haskey(cpu_stats, \\\"avg\\\")\\r\\n        @test haskey(cpu_stats, \\\"min\\\")\\r\\n        @test haskey(cpu_stats, \\\"max\\\")\\r\\n        @test haskey(cpu_stats, \\\"p95\\\")\\r\\n        @test cpu_stats[\\\"min\\\"] <= cpu_stats[\\\"avg\\\"] <= cpu_stats[\\\"max\\\"]\\r\\n        @test cpu_stats[\\\"avg\\\"] <= cpu_stats[\\\"p95\\\"] <= cpu_stats[\\\"max\\\"]\\r\\n\\r\\n        # Test API metrics aggregation\\r\\n        api_aggregation = aggregate_metrics(collector, \\\"api_response_times\\\", \\\"1_hour\\\")\\r\\n\\r\\n        @test !haskey(api_aggregation, \\\"error\\\")\\r\\n        @test haskey(api_aggregation, \\\"total_requests\\\")\\r\\n        @test haskey(api_aggregation, \\\"success_rate\\\")\\r\\n        @test haskey(api_aggregation, \\\"response_time_ms\\\")\\r\\n        @test haskey(api_aggregation, \\\"endpoint_breakdown\\\")\\r\\n        @test api_aggregation[\\\"total_requests\\\"] == 50\\r\\n        @test 0.0 <= api_aggregation[\\\"success_rate\\\"] <= 1.0\\r\\n\\r\\n        response_time_stats = api_aggregation[\\\"response_time_ms\\\"]\\r\\n        @test haskey(response_time_stats, \\\"avg\\\")\\r\\n        @test haskey(response_time_stats, \\\"p50\\\")\\r\\n        @test haskey(response_time_stats, \\\"p95\\\")\\r\\n        @test haskey(response_time_stats, \\\"p99\\\")\\r\\n        @test response_time_stats[\\\"min\\\"] <= response_time_stats[\\\"p50\\\"] <= response_time_stats[\\\"p95\\\"] <= response_time_stats[\\\"p99\\\"] <= response_time_stats[\\\"max\\\"]\\r\\n\\r\\n        # Test analysis metrics aggregation\\r\\n        analysis_aggregation = aggregate_metrics(collector, \\\"analysis_throughput\\\", \\\"1_hour\\\")\\r\\n\\r\\n        @test !haskey(analysis_aggregation, \\\"error\\\")\\r\\n        @test haskey(analysis_aggregation, \\\"total_analyses\\\")\\r\\n        @test haskey(analysis_aggregation, \\\"success_rate\\\")\\r\\n        @test haskey(analysis_aggregation, \\\"throughput\\\")\\r\\n        @test haskey(analysis_aggregation, \\\"agent_usage\\\")\\r\\n        @test analysis_aggregation[\\\"total_analyses\\\"] == 50\\r\\n\\r\\n        # Test different time periods\\r\\n        for period in [\\\"5_minutes\\\", \\\"15_minutes\\\", \\\"24_hours\\\"]\\r\\n            period_aggregation = aggregate_metrics(collector, \\\"system_performance\\\", period)\\r\\n            @test !haskey(period_aggregation, \\\"error\\\") || period_aggregation[\\\"error\\\"] == \\\"No data in time window\\\"\\r\\n        end\\r\\n\\r\\n        # Test error handling for invalid category\\r\\n        invalid_aggregation = aggregate_metrics(collector, \\\"nonexistent_category\\\", \\\"1_hour\\\")\\r\\n        @test haskey(invalid_aggregation, \\\"error\\\")\\r\\n        @test invalid_aggregation[\\\"error\\\"] == \\\"Category not found\\\"\\r\\n\\r\\n        aggregation_time = time() - aggregation_start\\r\\n        @test aggregation_time < 3.0  # Aggregation should be efficient\\r\\n\\r\\n        println(\\\"âœ… Metrics aggregation validated\\\")\\r\\n        println(\\\"ğŸ“Š System aggregation: \\$(system_aggregation[\\\"data_points\\\"]) data points\\\")\\r\\n        println(\\\"ğŸ“Š API success rate: \\$(round(api_aggregation[\\\"success_rate\\\"], digits=3))\\\")\\r\\n        println(\\\"ğŸ“Š Analysis success rate: \\$(round(analysis_aggregation[\\\"success_rate\\\"], digits=3))\\\")\\r\\n        println(\\\"ğŸ“Š Agent usage count: \\$(length(analysis_aggregation[\\\"agent_usage\\\"]))\\\")\\r\\n        println(\\\"âš¡ Aggregation time: \\$(round(aggregation_time, digits=3))s\\\")\\r\\n    end\\r\\n\\r\\n    @testset \\\"Dashboard Data Preparation\\\" begin\\r\\n        println(\\\"\\\\nğŸ“‹ Testing dashboard data preparation and widget generation...\\\")\\r\\n\\r\\n        dashboard_start = time()\\r\\n\\r\\n        collector = MetricsCollector()\\r\\n\\r\\n        # Generate comprehensive dataset\\r\\n        for i in 1:30\\r\\n            collect_system_metrics(collector)\\r\\n\\r\\n            # Vary API endpoints\\r\\n            endpoints = [\\\"/api/v1/wallet/analyze\\\", \\\"/api/v1/pattern/detect\\\", \\\"/api/v1/reports/generate\\\"]\\r\\n            collect_api_metrics(collector, endpoints[rand(1:length(endpoints))])\\r\\n\\r\\n            # Vary analysis types\\r\\n            analysis_types = [\\\"wallet_analysis\\\", \\\"pattern_detection\\\", \\\"risk_assessment\\\"]\\r\\n            collect_analysis_metrics(collector, analysis_types[rand(1:length(analysis_types))])\\r\\n        end\\r\\n\\r\\n        # Generate some alerts for testing\\r\\n        generate_alert(collector, \\\"system_warning\\\", \\\"Test warning alert\\\")\\r\\n        generate_alert(collector, \\\"api_performance\\\", \\\"Test API alert\\\")\\r\\n\\r\\n        # Prepare dashboard data\\r\\n        dashboard_data = prepare_dashboard_data(collector)\\r\\n\\r\\n        @test haskey(dashboard_data, \\\"timestamp\\\")\\r\\n        @test haskey(dashboard_data, \\\"widgets\\\")\\r\\n        @test haskey(dashboard_data, \\\"refresh_timestamp\\\")\\r\\n\\r\\n        widgets = dashboard_data[\\\"widgets\\\"]\\r\\n\\r\\n        # Test system overview widget\\r\\n        @test haskey(widgets, \\\"system_overview\\\")\\r\\n        system_overview = widgets[\\\"system_overview\\\"]\\r\\n        @test haskey(system_overview, \\\"status\\\")\\r\\n        @test haskey(system_overview, \\\"uptime_hours\\\")\\r\\n        @test haskey(system_overview, \\\"current_metrics\\\")\\r\\n        @test haskey(system_overview, \\\"alerts_count\\\")\\r\\n        @test system_overview[\\\"status\\\"] in [\\\"healthy\\\", \\\"warning\\\", \\\"critical\\\"]\\r\\n        @test system_overview[\\\"uptime_hours\\\"] >= 0.0\\r\\n        @test system_overview[\\\"alerts_count\\\"] >= 0\\r\\n\\r\\n        # Test API performance widget\\r\\n        @test haskey(widgets, \\\"api_performance\\\")\\r\\n        api_performance = widgets[\\\"api_performance\\\"]\\r\\n        @test haskey(api_performance, \\\"status\\\")\\r\\n        @test haskey(api_performance, \\\"hourly_stats\\\")\\r\\n        @test haskey(api_performance, \\\"error_rate\\\")\\r\\n        @test api_performance[\\\"status\\\"] in [\\\"healthy\\\", \\\"warning\\\", \\\"critical\\\", \\\"unknown\\\"]\\r\\n\\r\\n        # Test analysis throughput widget\\r\\n        @test haskey(widgets, \\\"analysis_throughput\\\")\\r\\n        analysis_widget = widgets[\\\"analysis_throughput\\\"]\\r\\n        @test haskey(analysis_widget, \\\"status\\\")\\r\\n        @test haskey(analysis_widget, \\\"hourly_stats\\\")\\r\\n        @test analysis_widget[\\\"status\\\"] in [\\\"healthy\\\", \\\"warning\\\", \\\"critical\\\", \\\"unknown\\\"]\\r\\n\\r\\n        # Test detective agents status widget\\r\\n        @test haskey(widgets, \\\"detective_agents_status\\\")\\r\\n        agents_widget = widgets[\\\"detective_agents_status\\\"]\\r\\n        @test haskey(agents_widget, \\\"agents_active\\\")\\r\\n        @test haskey(agents_widget, \\\"usage_stats\\\")\\r\\n        @test length(agents_widget[\\\"agents_active\\\"]) > 0\\r\\n\\r\\n        # Test blockchain health widget\\r\\n        @test haskey(widgets, \\\"blockchain_health\\\")\\r\\n        blockchain_widget = widgets[\\\"blockchain_health\\\"]\\r\\n        @test haskey(blockchain_widget, \\\"rpc_status\\\")\\r\\n        @test haskey(blockchain_widget, \\\"success_rate\\\")\\r\\n        @test blockchain_widget[\\\"rpc_status\\\"] == \\\"operational\\\"\\r\\n\\r\\n        # Test user activity widget\\r\\n        @test haskey(widgets, \\\"user_activity\\\")\\r\\n        user_widget = widgets[\\\"user_activity\\\"]\\r\\n        @test haskey(user_widget, \\\"active_sessions\\\")\\r\\n        @test haskey(user_widget, \\\"requests_per_hour\\\")\\r\\n        @test user_widget[\\\"active_sessions\\\"] >= 0\\r\\n\\r\\n        # Test error tracking widget\\r\\n        @test haskey(widgets, \\\"error_tracking\\\")\\r\\n        error_widget = widgets[\\\"error_tracking\\\"]\\r\\n        @test haskey(error_widget, \\\"error_rate\\\")\\r\\n        @test haskey(error_widget, \\\"errors_last_hour\\\")\\r\\n        @test error_widget[\\\"error_rate\\\"] >= 0.0\\r\\n\\r\\n        # Test resource utilization widget\\r\\n        @test haskey(widgets, \\\"resource_utilization\\\")\\r\\n        resource_widget = widgets[\\\"resource_utilization\\\"]\\r\\n        @test haskey(resource_widget, \\\"cpu_trend\\\")\\r\\n        @test haskey(resource_widget, \\\"memory_trend\\\")\\r\\n\\r\\n        dashboard_time = time() - dashboard_start\\r\\n        @test dashboard_time < 2.0  # Dashboard preparation should be efficient\\r\\n\\r\\n        println(\\\"âœ… Dashboard data preparation validated\\\")\\r\\n        println(\\\"ğŸ“Š Widgets generated: \\$(length(widgets))\\\")\\r\\n        println(\\\"ğŸ“Š System status: \\$(system_overview[\\\"status\\\"])\\\")\\r\\n        println(\\\"ğŸ“Š Uptime: \\$(round(system_overview[\\\"uptime_hours\\\"], digits=2)) hours\\\")\\r\\n        println(\\\"ğŸ“Š Total alerts: \\$(system_overview[\\\"alerts_count\\\"])\\\")\\r\\n        println(\\\"âš¡ Dashboard preparation: \\$(round(dashboard_time, digits=3))s\\\")\\r\\n    end\\r\\n\\r\\n    @testset \\\"Data Export and Historical Analysis\\\" begin\\r\\n        println(\\\"\\\\nğŸ’¾ Testing data export and historical analysis capabilities...\\\")\\r\\n\\r\\n        export_start = time()\\r\\n\\r\\n        collector = MetricsCollector()\\r\\n\\r\\n        # Generate historical data spanning different time periods\\r\\n        for i in 1:100\\r\\n            collect_system_metrics(collector)\\r\\n            collect_api_metrics(collector, \\\"/api/v1/export/test\\\")\\r\\n            collect_analysis_metrics(collector, \\\"historical_analysis\\\")\\r\\n\\r\\n            # Simulate time progression\\r\\n            if i % 10 == 0\\r\\n                sleep(0.01)\\r\\n            end\\r\\n        end\\r\\n\\r\\n        # Generate varied alerts\\r\\n        for severity in [\\\"system_warning\\\", \\\"system_critical\\\", \\\"api_performance\\\"]\\r\\n            generate_alert(collector, severity, \\\"Historical test alert - \\$(severity)\\\")\\r\\n        end\\r\\n\\r\\n        # Test JSON export\\r\\n        json_export = export_metrics_data(collector, \\\"json\\\", \\\"24_hours\\\")\\r\\n\\r\\n        @test haskey(json_export, \\\"export_timestamp\\\")\\r\\n        @test haskey(json_export, \\\"time_range\\\")\\r\\n        @test haskey(json_export, \\\"format\\\")\\r\\n        @test haskey(json_export, \\\"collector_info\\\")\\r\\n        @test haskey(json_export, \\\"metrics_summary\\\")\\r\\n        @test haskey(json_export, \\\"aggregated_data\\\")\\r\\n        @test haskey(json_export, \\\"recent_alerts\\\")\\r\\n\\r\\n        @test json_export[\\\"format\\\"] == \\\"json\\\"\\r\\n        @test json_export[\\\"time_range\\\"] == \\\"24_hours\\\"\\r\\n\\r\\n        collector_info = json_export[\\\"collector_info\\\"]\\r\\n        @test haskey(collector_info, \\\"collector_id\\\")\\r\\n        @test haskey(collector_info, \\\"start_time\\\")\\r\\n        @test haskey(collector_info, \\\"collection_frequency\\\")\\r\\n        @test collector_info[\\\"collector_id\\\"] == collector.collector_id\\r\\n\\r\\n        metrics_summary = json_export[\\\"metrics_summary\\\"]\\r\\n        @test haskey(metrics_summary, \\\"total_categories\\\")\\r\\n        @test haskey(metrics_summary, \\\"total_data_points\\\")\\r\\n        @test haskey(metrics_summary, \\\"alert_count\\\")\\r\\n        @test metrics_summary[\\\"total_categories\\\"] == length(collector.metrics_buffer)\\r\\n        @test metrics_summary[\\\"total_data_points\\\"] > 0\\r\\n        @test metrics_summary[\\\"alert_count\\\"] >= 3  # At least the test alerts we generated\\r\\n\\r\\n        # Verify aggregated data contains expected categories\\r\\n        aggregated_data = json_export[\\\"aggregated_data\\\"]\\r\\n        @test haskey(aggregated_data, \\\"system_performance\\\")\\r\\n        @test haskey(aggregated_data, \\\"api_response_times\\\")\\r\\n        @test haskey(aggregated_data, \\\"analysis_throughput\\\")\\r\\n\\r\\n        # Test different time ranges\\r\\n        for time_range in [\\\"1_hour\\\", \\\"6_hours\\\", \\\"7_days\\\"]\\r\\n            range_export = export_metrics_data(collector, \\\"json\\\", time_range)\\r\\n            @test range_export[\\\"time_range\\\"] == time_range\\r\\n            @test haskey(range_export, \\\"aggregated_data\\\")\\r\\n        end\\r\\n\\r\\n        # Verify recent alerts in export\\r\\n        recent_alerts = json_export[\\\"recent_alerts\\\"]\\r\\n        @test length(recent_alerts) >= 3  # Should include our test alerts\\r\\n\\r\\n        for alert in recent_alerts[end-2:end]  # Check last 3 alerts\\r\\n            @test haskey(alert, \\\"alert_id\\\")\\r\\n            @test haskey(alert, \\\"severity\\\")\\r\\n            @test haskey(alert, \\\"message\\\")\\r\\n            @test haskey(alert, \\\"timestamp\\\")\\r\\n        end\\r\\n\\r\\n        # Test export data integrity\\r\\n        @test json_export[\\\"export_timestamp\\\"] isa DateTime\\r\\n        @test metrics_summary[\\\"total_data_points\\\"] == sum(length(v) for v in values(collector.metrics_buffer))\\r\\n\\r\\n        export_time = time() - export_start\\r\\n        @test export_time < 3.0  # Export should be reasonably fast\\r\\n\\r\\n        # Generate comprehensive metrics performance report\\r\\n        metrics_report = Dict(\\r\\n            \\\"test_timestamp\\\" => Dates.format(now(), \\\"yyyy-mm-dd HH:MM:SS\\\"),\\r\\n            \\\"collector_performance\\\" => Dict(\\r\\n                \\\"data_points_processed\\\" => metrics_summary[\\\"total_data_points\\\"],\\r\\n                \\\"categories_tracked\\\" => metrics_summary[\\\"total_categories\\\"],\\r\\n                \\\"alerts_generated\\\" => metrics_summary[\\\"alert_count\\\"],\\r\\n                \\\"collection_efficiency\\\" => export_time / metrics_summary[\\\"total_data_points\\\"] * 1000  # ms per data point\\r\\n            ),\\r\\n            \\\"aggregation_analysis\\\" => Dict(\\r\\n                \\\"system_metrics_available\\\" => haskey(aggregated_data, \\\"system_performance\\\"),\\r\\n                \\\"api_metrics_available\\\" => haskey(aggregated_data, \\\"api_response_times\\\"),\\r\\n                \\\"analysis_metrics_available\\\" => haskey(aggregated_data, \\\"analysis_throughput\\\"),\\r\\n                \\\"aggregation_completeness\\\" => length(aggregated_data) / length(collector.metrics_buffer)\\r\\n            ),\\r\\n            \\\"export_verification\\\" => json_export,\\r\\n            \\\"performance_benchmarks\\\" => Dict(\\r\\n                \\\"collection_time_per_metric_ms\\\" => export_time / metrics_summary[\\\"total_data_points\\\"] * 1000,\\r\\n                \\\"export_efficiency\\\" => \\\"efficient\\\",\\r\\n                \\\"data_integrity\\\" => \\\"verified\\\"\\r\\n            )\\r\\n        )\\r\\n\\r\\n        # Save metrics performance report\\r\\n        results_dir = joinpath(@__DIR__, \\\"results\\\")\\r\\n        if !isdir(results_dir)\\r\\n            mkpath(results_dir)\\r\\n        end\\r\\n\\r\\n        report_filename = \\\"metrics_handlers_report_\\$(Dates.format(now(), \\\"yyyy-mm-dd_HH-MM-SS\\\")).json\\\"\\r\\n        report_path = joinpath(results_dir, report_filename)\\r\\n\\r\\n        open(report_path, \\\"w\\\") do f\\r\\n            JSON.print(f, metrics_report, 2)\\r\\n        end\\r\\n\\r\\n        @test isfile(report_path)\\r\\n\\r\\n        println(\\\"âœ… Data export and analysis validated\\\")\\r\\n        println(\\\"ğŸ“Š Data points exported: \\$(metrics_summary[\\\"total_data_points\\\"])\\\")\\r\\n        println(\\\"ğŸ“Š Categories tracked: \\$(metrics_summary[\\\"total_categories\\\"])\\\")\\r\\n        println(\\\"ğŸ“Š Alerts in export: \\$(length(recent_alerts))\\\")\\r\\n        println(\\\"ğŸ“Š Export completeness: \\$(round(length(aggregated_data) / length(collector.metrics_buffer), digits=2))\\\")\\r\\n        println(\\\"ğŸ’¾ Metrics report: \\$(report_filename)\\\")\\r\\n        println(\\\"âš¡ Export processing: \\$(round(export_time, digits=3))s\\\")\\r\\n    end\\r\\n\\r\\n    println(\\\"\\\\n\\\" * \\\"=\\\"^80)\\r\\n    println(\\\"ğŸ¯ METRICS HANDLERS VALIDATION COMPLETE\\\")\\r\\n    println(\\\"âœ… Performance metrics collection operational (<100ms collection)\\\")\\r\\n    println(\\\"âœ… Real-time alert generation and monitoring functional\\\")\\r\\n    println(\\\"âœ… Statistical aggregation and trend analysis validated\\\")\\r\\n    println(\\\"âœ… Dashboard data preparation for 8 widget types confirmed\\\")\\r\\n    println(\\\"âœ… Historical data export and analysis capabilities verified\\\")\\r\\n    println(\\\"âœ… System health monitoring with configurable thresholds operational\\\")\\r\\n    println(\\\"=\\\"^80)\\r\\nend\\r\\n\", 0, \"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_metrics_handlers.jl\", 1, [1, 245, 332, 420, 507, 594, 682, 771, 860, 949, 1038, 1126, 1213, 1299, 1385, 1473, 1717, 1719, 1764, 1820, 1822, 2063, 2129, 2370, 2372, 2401, 2428, 2455, 2487, 2515, 2551, 2573, 2593, 2621, 2624, 2626, 2664, 2738, 2816, 2888, 2957, 3025, 3106, 3177, 3180, 3182, 3220, 3237, 3255, 3274, 3289, 3305, 3322, 3336, 3339, 3341, 3370, 3394, 3418, 3446, 3478, 3504, 3526, 3549, 3577, 3580, 3582, 3823, 3860, 4101, 4103, 4136, 4162, 4188, 4249, 4306, 4352, 4402, 4444, 4466, 4490, 4495, 4497, 4556, 4586, 4632, 4648, 4700, 4744, 4774, 4808, 4839, 4887, 4901, 4908, 4913, 4915, 4945, 4970, 5002, 5037, 5070, 5097, 5125, 5154, 5183, 5221, 5226, 5228, 5254, 5281, 5297, 5349, 5404, 5457, 5506, 5556, 5607, 5653, 5704, 5711, 5716, 5718, 5745, 5767, 5787, 5818, 5840, 5870, 5899, 5924, 5942, 5966, 5971, 5973, 6036, 6060, 6079, 6096, 6158, 6221, 6274, 6313, 6329, 6387, 6442, 6449, 6454, 6456, 6488, 6513, 6540, 6563, 6591, 6623, 6648, 6676, 6719, 6744, 6763, 6768, 6770, 6819, 6848, 6893, 6917, 6973, 7035, 7090, 7140, 7194, 7264, 7280, 7336, 7343, 7348, 7350, 7591, 7629, 7870, 7872, 7934, 7988, 7990, 8021, 8047, 8090, 8141, 8198, 8251, 8302, 8355, 8416, 8477, 8542, 8549, 8551, 8580, 8644, 8722, 8731, 8733, 8806, 8808, 8832, 8887, 8889, 8914, 8919, 8921, 9022, 9074, 9076, 9124, 9150, 9197, 9242, 9283, 9344, 9395, 9456, 9510, 9551, 9603, 9610, 9612, 9641, 9705, 9783, 9792, 9794, 9867, 9869, 9905, 10002, 10133, 10142, 10144, 10169, 10174, 10176, 10263, 10322, 10324, 10379, 10405, 10457, 10513, 10573, 10631, 10699, 10767, 10821, 10889, 10955, 11002, 11009, 11011, 11040, 11105, 11184, 11193, 11195, 11269, 11271, 11312, 11421, 11558, 11567, 11569, 11594, 11599, 11601, 11693, 11776, 11778, 11804, 11806, 11829, 11916, 12035, 12066, 12156, 12270, 12301, 12310, 12312, 12338, 12431, 12556, 12587, 12683, 12803, 12834, 12843, 12845, 12874, 12879, 12881, 12970, 13033, 13035, 13054, 13110, 13141, 13174, 13205, 13239, 13268, 13275, 13277, 13320, 13322, 13356, 13403, 13475, 13484, 13486, 13504, 13509, 13511, 13602, 13670, 13672, 13724, 13778, 13787, 13789, 13844, 13874, 13927, 13936, 13938, 13967, 13993, 14036, 14082, 14084, 14125, 14205, 14207, 14241, 14299, 14308, 14310, 14355, 14396, 14455, 14500, 14556, 14602, 14663, 14673, 14733, 14742, 14747, 14749, 14820, 14868, 14870, 14922, 14980, 14982, 15000, 15069, 15136, 15179, 15209, 15249, 15292, 15335, 15384, 15396, 15429, 15472, 15518, 15564, 15616, 15628, 15667, 15739, 15813, 15824, 15831, 15836, 15838, 15906, 15951, 15953, 16016, 16082, 16084, 16109, 16165, 16192, 16231, 16277, 16337, 16350, 16399, 16408, 16410, 16428, 16497, 16564, 16610, 16670, 16707, 16751, 16798, 16845, 16898, 16952, 17005, 17017, 17056, 17087, 17138, 17224, 17318, 17373, 17385, 17467, 17567, 17574, 17579, 17581, 17654, 17715, 17717, 17783, 17845, 17847, 17865, 17934, 18001, 18047, 18113, 18151, 18197, 18246, 18295, 18350, 18362, 18393, 18466, 18549, 18636, 18732, 18744, 18778, 18853, 18941, 18953, 19006, 19013, 19018, 19020, 19084, 19134, 19136, 19176, 19178, 19205, 19249, 19316, 19329, 19338, 19340, 19365, 19370, 19372, 19414, 19468, 19470, 19499, 19525, 19559, 19585, 19620, 19647, 19678, 19702, 19734, 19758, 19791, 19816, 19847, 19870, 19880, 19925, 19934, 19939, 19941, 20182, 20212, 20453, 20455, 20517, 20578, 20580, 20606, 20608, 20637, 20699, 20701, 20755, 20837, 20916, 21001, 21003, 21030, 21058, 21096, 21124, 21164, 21240, 21336, 21396, 21498, 21514, 21554, 21617, 21664, 21730, 21795, 21811, 21855, 21928, 21980, 22052, 22124, 22140, 22188, 22266, 22334, 22407, 22423, 22465, 22513, 22565, 22622, 22678, 22694, 22732, 22784, 22840, 22894, 22910, 22949, 23035, 23101, 23160, 23176, 23221, 23279, 23343, 23405, 23420, 23432, 23477, 23484, 23486, 23513, 23518, 23520, 23582, 23650, 23652, 23684, 23722, 23724, 23797, 23873, 23900, 23976, 24055, 24081, 24091, 24117, 24126, 24131, 24133, 24183, 24227, 24229, 24310, 24336, 24345, 24347, 24411, 24459, 24461, 24551, 24641, 24668, 24761, 24854, 24880, 24890, 24916, 24925, 24930, 24932, 24989, 25040, 25042, 25106, 25125, 25134, 25136, 25198, 25241, 25243, 25290, 25325, 25398, 25400, 25434, 25473, 25548, 25557, 25559, 25597, 25674, 25802, 25807, 25809, 25869, 25920, 25922, 25986, 26006, 26015, 26017, 26048, 26083, 26195, 26197, 26229, 26249, 26258, 26260, 26332, 26389, 26394, 26396, 26457, 26505, 26507, 26572, 26595, 26604, 26606, 26641, 26677, 26791, 26793, 26846, 26848, 26885, 26931, 26975, 27070, 27087, 27139, 27229, 27242, 27251, 27253, 27279, 27318, 27355, 27453, 27466, 27475, 27477, 27501, 27506, 27508, 27625, 27676, 27678, 27703, 27741, 27778, 27807, 27842, 27897, 27948, 28018, 28030, 28066, 28135, 28229, 28291, 28303, 28340, 28347, 28349, 28394, 28446, 28549, 28558, 28560, 28585, 28683, 28685, 28709, 28714, 28716, 28957, 28995, 29236, 29238, 29315, 29343, 29408, 29429, 29431, 29484, 29564, 29566, 29601, 29603, 29677, 29679, 29729, 29780, 29826, 29879, 29881, 29923, 29982, 29984, 30034, 30084, 30137, 30196, 30254, 30315, 30371, 30373, 30443, 30518, 30520, 30559, 30586, 30625, 30664, 30705, 30716, 30718, 30757, 30824, 30826, 30876, 30934, 30987, 31041, 31097, 31161, 31174, 31176, 31246, 31341, 31343, 31387, 31478, 31480, 31525, 31607, 31609, 31669, 31733, 31787, 31856, 31918, 31980, 31993, 31995, 32066, 32163, 32165, 32218, 32284, 32286, 32339, 32446, 32550, 32660, 32738, 32747, 32749, 32815, 32897, 32899, 32929, 32931, 32971, 32973, 33016, 33048, 33083, 33117, 33154, 33188, 33199, 33201, 33264, 33344, 33346, 33383, 33453, 33455, 33497, 33530, 33565, 33632, 33702, 33736, 33747, 33749, 33828, 33830, 33892, 33961, 33963, 33997, 34057, 34093, 34138, 34184, 34229, 34273, 34330, 34372, 34410, 34423, 34425, 34468, 34502, 34537, 34605, 34676, 34710, 34721, 34723, 34804, 34806, 34876, 34878, 34919, 35002, 35045, 35125, 35207, 35209, 35267, 35329, 35402, 35404, 35450, 35559, 35643, 35656, 35658, 35726, 35728, 35771, 35843, 35845, 35898, 35982, 36041, 36102, 36176, 36185, 36187, 36242, 36325, 36327, 36363, 36365, 36405, 36407, 36463, 36486, 36533, 36602, 36668, 36670, 36726, 36751, 36764, 36766, 36842, 36918, 36995, 36997, 37040, 37131, 37133, 37185, 37242, 37297, 37355, 37410, 37412, 37465, 37505, 37545, 37585, 37625, 37697, 37769, 37771, 37811, 37899, 37901, 37950, 38007, 38062, 38121, 38182, 38237, 38298, 38300, 38367, 38417, 38467, 38517, 38567, 38729, 38731, 38776, 38870, 38872, 38926, 38988, 39048, 39106, 39165, 39225, 39227, 39266, 39329, 39422, 39537, 39550, 39552, 39604, 39698, 39750, 39818, 39820, 39875, 39948, 39950, 40004, 40098, 40193, 40298, 40389, 40469, 40478, 40480, 40529, 40616, 40618, 40652, 40654, 40694, 40696, 40738, 40761, 40808, 40810, 40844, 40950, 41032, 41034, 41069, 41159, 41256, 41269, 41271, 41315, 41390, 41462, 41464, 41498, 41558, 41560, 41611, 41660, 41719, 41721, 41766, 41768, 41807, 41857, 41911, 41960, 42015, 42073, 42128, 42207, 42261, 42313, 42315, 42354, 42404, 42458, 42507, 42562, 42615, 42705, 42707, 42750, 42804, 42862, 42911, 42966, 43056, 43058, 43105, 43163, 43223, 43277, 43329, 43387, 43389, 43430, 43482, 43540, 43595, 43652, 43716, 43718, 43755, 43803, 43851, 43905, 43961, 44012, 44014, 44052, 44101, 44151, 44201, 44257, 44306, 44308, 44352, 44407, 44466, 44518, 44573, 44575, 44626, 44707, 44709, 44770, 44833, 44902, 44993, 45067, 45150, 45159, 45161, 45219, 45306, 45308, 45339, 45341, 45381, 45383, 45451, 45475, 45522, 45589, 45661, 45663, 45704, 45732, 45761, 45778, 45791, 45793, 45827, 45909, 45997, 46010, 46012, 46040, 46114, 46116, 46171, 46220, 46265, 46318, 46372, 46426, 46478, 46480, 46527, 46582, 46584, 46640, 46694, 46746, 46808, 46880, 46882, 46940, 46999, 47059, 47113, 47200, 47256, 47348, 47350, 47413, 47471, 47532, 47593, 47655, 47657, 47695, 47754, 47833, 47893, 47952, 47965, 47967, 48009, 48063, 48139, 48141, 48211, 48256, 48301, 48345, 48391, 48404, 48406, 48444, 48504, 48616, 48618, 48663, 48732, 48734, 48795, 48827, 48904, 48950, 49032, 49110, 49181, 49304, 49320, 49365, 49459, 49550, 49647, 49753, 49769, 49820, 49867, 49978, 50031, 50079, 50094, 50105, 50107, 50150, 50203, 50235, 50268, 50281, 50283, 50387, 50449, 50451, 50488, 50534, 50547, 50549, 50584, 50586, 50645, 50732, 50816, 50884, 51009, 51069, 51145, 51154, 51156, 51184, 51242, 51325, 51398, 51471, 51547, 51625, 51711, 51732, 51737]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(25729, 25742, :error, \"Expected `end`\"), Base.JuliaSyntax.Diagnostic(25743, 25799, :error, \"extra tokens after end of expression\"), Base.JuliaSyntax.Diagnostic(25802, 25804, :error, \"invalid identifier\")], :none)))","ok":false,"file":"test_metrics_handlers.jl","seconds":0.1789999008178711},{"error":null,"ok":true,"file":"test_streaming_analysis.jl","seconds":4.898999929428101},{"error":null,"ok":true,"file":"test_unified_investigation.jl","seconds":4.453999996185303},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_webhook_handler.jl\", 406, Some tests did not pass: 95 passed, 1 failed, 0 errored, 0 broken.)","ok":false,"file":"test_webhook_handler.jl","seconds":12.533999919891357},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\blockchain\\\\test_address_validation.jl\", 20, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\Blockchain.jl\", 472, Base.Meta.ParseError(\"ParseError:\\n# Error @ C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\Blockchain.jl:472:25\\n\\nend # module Blockchain\\n#                      \\nâ”” â”€â”€ unterminated string literal\", Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(\"\\\"\\\"\\\"\\nBlockchain.jl - Core module for blockchain interactions in JuliaOS.\\n\\nProvides a unified interface for interacting with various blockchain networks,\\nincluding EVM-compatible chains and others like Solana.\\n\\\"\\\"\\\"\\nmodule Blockchain\\n\\nusing HTTP, JSON3, Dates, Base64, Printf, Logging\\n\\n# Include the main application configuration module\\ntry\\n    include(\\\"../config/config.jl\\\") # Path from src/blockchain/ to config/\\n    MainAppConfig = Config # Alias the loaded Config module\\n    @info \\\"Blockchain.jl: Successfully included main application config.\\\"\\ncatch e\\n    @error \\\"Blockchain.jl: Failed to include main application config. Will use internal defaults.\\\" exception=e\\n    # Define a fallback AppConfigModule if main config fails to load\\n    module MainAppConfig\\n        load() = nothing # Placeholder\\n        get_value(cfg, key, default) = default\\n    end\\nend\\n\\n# Include submodules or specific client implementations\\ninclude(\\\"EthereumClient.jl\\\") # Assuming EthereumClient.jl is in the same directory\\n# Wallet.jl is simplified and no longer directly used for signing by Blockchain.jl's core generic functions.\\n# If any utility from Wallet.jl (like address validation) were needed, it could be `using .Wallet`\\n# but for now, its primary role (dev wallet object) is not used by these generic functions.\\n\\n# Re-export key functionalities from submodules if they are namespaced\\nusing .EthereumClient \\n# using .Wallet # Not strictly needed if Blockchain.jl doesn't use Wallet types/functions directly\\n\\nexport connect, get_balance, get_transaction_receipt_generic, is_node_healthy_generic\\nexport get_chain_id_generic, get_gas_price_generic, get_token_balance_generic, send_raw_transaction_generic, eth_call_generic\\nexport get_transaction_count_generic, estimate_gas_generic, get_decimals_generic\\nexport SUPPORTED_CHAINS_CONFIG, get_rpc_endpoint, get_chain_name_from_id \\n\\n# Configuration for supported blockchain networks will be loaded from MainAppConfig\\n\\nconst SUPPORTED_CHAINS_CONFIG = Ref(Dict{String, Dict{String,Any}}()) # To be populated by _load_blockchain_config\\n\\nfunction _load_blockchain_config()\\n    app_config = MainAppConfig.load() # Load the main application configuration\\n    \\n    if isnothing(app_config)\\n        @error \\\"Blockchain.jl: Main application configuration could not be loaded. Using empty blockchain config.\\\"\\n        SUPPORTED_CHAINS_CONFIG[] = Dict{String, Dict{String,Any}}()\\n        return\\n    end\\n\\n    # Get RPC URLs and supported chains from the loaded application config\\n    # The paths like \\\"blockchain.rpc_urls\\\" are based on the structure in julia/config/config.jl's DEFAULT_CONFIG\\n    rpc_urls_from_config = MainAppConfig.get_value(app_config, \\\"blockchain.rpc_urls\\\", Dict())\\n    supported_chains_list = MainAppConfig.get_value(app_config, \\\"blockchain.supported_chains\\\", []) # List of chain names\\n\\n    loaded_config = Dict{String, Dict{String,Any}}()\\n\\n    # Prioritize chains listed in \\\"supported_chains\\\" from config\\n    for chain_key_any in supported_chains_list\\n        chain_key = lowercase(string(chain_key_any)) # Ensure lowercase string\\n        \\n        # Get RPC URL: ENV variable > config file's rpc_urls section > hardcoded DEFAULT_RPC_URLS (as last resort)\\n        env_var_name = uppercase(chain_key) * \\\"_RPC_URL\\\"\\n        rpc_url = get(ENV, env_var_name, get(rpc_urls_from_config, chain_key, get(DEFAULT_RPC_URLS, chain_key, \\\"\\\")))\\n\\n        if isempty(rpc_url)\\n            @warn \\\"No RPC URL found for supported chain: \\$chain_key (checked ENV.\\$env_var_name, config.blockchain.rpc_urls.\\$chain_key, and internal defaults).\\\"\\n            continue\\n        end\\n        \\n        # Chain ID mapping (can be expanded or made configurable, or fetched from node if possible)\\n        chain_id = if chain_key == \\\"ethereum\\\"; 1\\n                     elseif chain_key == \\\"polygon\\\"; 137\\n                     elseif chain_key == \\\"arbitrum\\\"; 42161\\n                     elseif chain_key == \\\"optimism\\\"; 10\\n                     elseif chain_key == \\\"base\\\"; 8453\\n                     elseif chain_key == \\\"avalanche\\\"; 43114\\n                     elseif chain_key == \\\"bsc\\\"; 56\\n                     elseif chain_key == \\\"fantom\\\"; 250\\n                     elseif chain_key == \\\"solana\\\"; -1 # Special value for Solana\\n                     else; 0 # Unknown or to be fetched\\n                     end\\n        \\n        loaded_config[chain_key] = Dict(\\\"rpc_url\\\" => rpc_url, \\\"chain_id\\\" => chain_id, \\\"name\\\" => chain_key)\\n    end\\n    \\n    # Fallback for any chains in DEFAULT_RPC_URLS not covered by supported_chains_list (e.g. if supported_chains is empty)\\n    # This ensures some level of default functionality if config is minimal.\\n    if isempty(loaded_config) && !isempty(DEFAULT_RPC_URLS)\\n        @warn \\\"blockchain.supported_chains list in config was empty or resulted in no valid configurations. Falling back to internal DEFAULT_RPC_URLS.\\\"\\n        for (chain_key, default_url) in DEFAULT_RPC_URLS\\n            if !haskey(loaded_config, chain_key) # Add only if not already processed\\n                env_var_name = uppercase(chain_key) * \\\"_RPC_URL\\\"\\n                rpc_url = get(ENV, env_var_name, default_url) # ENV still takes precedence over hardcoded default\\n                chain_id = if chain_key == \\\"ethereum\\\"; 1 elseif chain_key == \\\"polygon\\\"; 137 elseif chain_key == \\\"solana\\\"; -1 else 0 end # Simplified\\n                loaded_config[chain_key] = Dict(\\\"rpc_url\\\" => rpc_url, \\\"chain_id\\\" => chain_id, \\\"name\\\" => chain_key)\\n            end\\n        end\\n    end\\n\\n    SUPPORTED_CHAINS_CONFIG[] = loaded_config\\n    @info \\\"Blockchain configuration initialized with \\$(length(SUPPORTED_CHAINS_CONFIG[])) chains from main application config and environment variables.\\\"\\nend\\n\\n# Define DEFAULT_RPC_URLS here as a fallback if config system fails or is minimal\\nconst DEFAULT_RPC_URLS = Dict(\\n    \\\"ethereum\\\" => \\\"https://mainnet.infura.io/v3/YOUR_INFURA_KEY\\\", # User should replace this\\n    \\\"polygon\\\"  => \\\"https://polygon-rpc.com\\\",\\n    \\\"solana\\\"   => \\\"https://api.mainnet-beta.solana.com\\\"\\n    # Add other common defaults if desired\\n)\\n\\nfunction __init__()\\n    _load_blockchain_config() # Load config when module is initialized\\nend\\n\\nfunction get_rpc_endpoint(network_name_or_id::Union{String, Int})::Union{String, Nothing}\\n    configs = SUPPORTED_CHAINS_CONFIG[]\\n    if isa(network_name_or_id, String)\\n        norm_name = lowercase(network_name_or_id)\\n        return haskey(configs, norm_name) ? configs[norm_name][\\\"rpc_url\\\"] : nothing\\n    elseif isa(network_name_or_id, Int) # Lookup by chain_id\\n        for (name, details) in configs\\n            if details[\\\"chain_id\\\"] == network_name_or_id\\n                return details[\\\"rpc_url\\\"]\\n            end\\n        end\\n        return nothing\\n    end\\n    return nothing\\nend\\n\\nfunction get_chain_name_from_id(chain_id::Int)::Union{String, Nothing}\\n    configs = SUPPORTED_CHAINS_CONFIG[]\\n    for (name, details) in configs\\n        if details[\\\"chain_id\\\"] == chain_id\\n            return name\\n        end\\n    end\\n    return nothing\\nend\\n\\n\\n\\\"\\\"\\\"\\n    connect(; network::String=\\\"ethereum\\\", endpoint_url::Union{String,Nothing}=nothing)\\n\\nEstablishes and tests a connection to a specified blockchain network.\\nReturns a dictionary representing the connection state.\\n\\\"\\\"\\\"\\nfunction connect(; network::String=\\\"ethereum\\\", endpoint_url::Union{String,Nothing}=nothing)\\n    norm_network_name = lowercase(network)\\n    \\n    final_endpoint_url = if !isnothing(endpoint_url)\\n        endpoint_url\\n    else\\n        get_rpc_endpoint(norm_network_name)\\n    end\\n\\n    if isnothing(final_endpoint_url)\\n        @error \\\"No RPC endpoint configured or found for network: \\$norm_network_name.\\\"\\n        return Dict(\\\"network\\\" => norm_network_name, \\\"endpoint\\\" => nothing, \\\"connected\\\" => false, \\\"error\\\" => \\\"RPC endpoint not configured\\\")\\n    end\\n\\n    is_healthy = is_node_healthy_generic(norm_network_name, final_endpoint_url)\\n    \\n    chain_id = -1 # Default for unknown or non-EVM\\n    if is_healthy && norm_network_name != \\\"solana\\\" # Solana doesn't have eth_chainId\\n        try\\n            # Attempt to get chain_id for EVM chains\\n            temp_conn_dict = Dict(\\\"network\\\" => norm_network_name, \\\"endpoint\\\" => final_endpoint_url, \\\"connected\\\" => true)\\n            chain_id = get_chain_id_generic(temp_conn_dict)\\n        catch e\\n            @warn \\\"Could not fetch chain_id for \\$norm_network_name via \\$final_endpoint_url\\\" error=e\\n        end\\n    end\\n\\n    return Dict(\\n        \\\"network\\\" => norm_network_name,\\n        \\\"endpoint\\\" => final_endpoint_url,\\n        \\\"connected\\\" => is_healthy,\\n        \\\"chain_id_retrieved\\\" => chain_id, # May differ from configured if endpoint is wrong\\n        \\\"timestamp\\\" => string(now(UTC))\\n    )\\nend\\n\\n# Generic RPC request helper (primarily for EVM-like JSON-RPC)\\nfunction _make_generic_rpc_request(endpoint_url::String, method::String, params::AbstractArray)\\n    request_body = Dict(\\n        \\\"jsonrpc\\\" => \\\"2.0\\\",\\n        \\\"id\\\" => rand(UInt32),\\n        \\\"method\\\" => method,\\n        \\\"params\\\" => params\\n    )\\n    try\\n        response = HTTP.post(\\n            endpoint_url,\\n            [\\\"Content-Type\\\" => \\\"application/json\\\"],\\n            JSON3.write(request_body);\\n            timeout = 20 # Default timeout\\n        )\\n        response_json = JSON3.read(String(response.body))\\n        \\n        if haskey(response_json, \\\"error\\\")\\n            err_details = response_json.error\\n            err_msg = \\\"RPC Error for method \\$method: \\$(get(err_details, \\\"message\\\", \\\"Unknown RPC error\\\")) (Code: \\$(get(err_details, \\\"code\\\", \\\"N/A\\\")))\\\"\\n            @error err_msg full_error=err_details\\n            error(err_msg) # Throw an error to be caught by calling function\\n        end\\n        return response_json.result\\n    catch e\\n        @error \\\"Generic RPC request failed for method \\$method to \\$endpoint_url\\\" exception=(e, catch_backtrace())\\n        rethrow(e) # Propagate the exception\\n    end\\nend\\n\\n# --- Generic Blockchain Interaction Functions ---\\n# These will delegate to chain-specific implementations or use generic JSON-RPC.\\n\\nfunction is_node_healthy_generic(network_name::String, endpoint_url::String)::Bool\\n    try\\n        if network_name == \\\"solana\\\"\\n            # Solana-specific health check\\n            result = _make_generic_rpc_request(endpoint_url, \\\"getHealth\\\", [])\\n            return result == \\\"ok\\\"\\n        else # Assume EVM-compatible\\n            result = _make_generic_rpc_request(endpoint_url, \\\"web3_clientVersion\\\", [])\\n            return !isnothing(result) && !isempty(result)\\n        end\\n    catch e\\n        @warn \\\"Node health check failed for \\$network_name at \\$endpoint_url\\\" error=e\\n        return false\\n    end\\nend\\n\\nfunction get_chain_id_generic(connection::Dict)::Int\\n    # `connection` is the Dict returned by `connect()`\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected to network: \\$(connection[\\\"network\\\"])\\\") end\\n    \\n    if connection[\\\"network\\\"] == \\\"solana\\\"\\n        # Solana doesn't have a numeric chain ID in the EVM sense.\\n        # Mainnet-beta, Testnet, Devnet are identified by cluster URL or genesis hash.\\n        # We can return a conventional value or error.\\n        @warn \\\"get_chain_id_generic: Solana does not use numeric chain IDs like EVM chains. Returning conventional -1.\\\"\\n        return -1 \\n    end\\n    # Assumes EVM chain\\n    hex_chain_id = _make_generic_rpc_request(connection[\\\"endpoint\\\"], \\\"eth_chainId\\\", [])\\n    return parse(Int, hex_chain_id[3:end], base=16)\\nend\\n\\n\\nfunction get_balance_generic(address::String, connection::Dict)::Float64\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected to network: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n\\n    try\\n        if network == \\\"solana\\\"\\n            result = _make_generic_rpc_request(endpoint, \\\"getBalance\\\", [address])\\n            balance_lamports = result[\\\"value\\\"] # result is Dict(\\\"context\\\"=>..., \\\"value\\\"=>...)\\n            return balance_lamports / 1_000_000_000 # Lamports to SOL\\n        else # Assume EVM\\n            hex_result = _make_generic_rpc_request(endpoint, \\\"eth_getBalance\\\", [address, \\\"latest\\\"])\\n            balance_wei = parse(BigInt, hex_result[3:end], base=16)\\n            return Float64(balance_wei / BigInt(10)^18) # Wei to Ether\\n        end\\n    catch e\\n        @error \\\"Error getting balance for \\$address on \\$network\\\" error=e\\n        return 0.0 # Fallback\\n    end\\nend\\n\\nfunction get_token_balance_generic(wallet_address::String, token_contract_address::String, connection::Dict)::Float64\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n\\n    try\\n        if network == \\\"solana\\\"\\n            # SPL Token Balance for Solana\\n            # This requires knowing the token's mint address and the associated token account for the wallet.\\n            # A common approach is to use `getTokenAccountsByOwner` then find the one for the mint.\\n            # This is a simplified placeholder.\\n            @warn \\\"get_token_balance_generic for Solana SPL tokens is a complex placeholder.\\\"\\n            # params = [wallet_address, Dict(\\\"mint\\\" => token_contract_address), Dict(\\\"encoding\\\" => \\\"jsonParsed\\\")]\\n            # result = _make_generic_rpc_request(endpoint, \\\"getTokenAccountsByOwner\\\", params)\\n            # if !isempty(result[\\\"value\\\"]) ... parse result ... end\\n            return 0.0 # Placeholder\\n        else # Assume EVM ERC20\\n            # ERC20 balanceOf(address) function signature: 0x70a08231\\n            padded_address = lpad(wallet_address[3:end], 64, '0') # Remove 0x and pad\\n            data = \\\"0x70a08231\\\" * padded_address\\n            \\n            hex_balance = eth_call_generic(token_contract_address, data, connection)\\n            balance_smallest_unit = parse(BigInt, hex_balance[3:end], base=16)\\n            \\n            # Get token decimals\\n            token_decimals = get_decimals_generic(token_contract_address, connection)\\n            return Float64(balance_smallest_unit / BigInt(10)^token_decimals)\\n        end\\n    catch e\\n        @error \\\"Error getting token balance for \\$wallet_address, token \\$token_contract_address on \\$network\\\" error=e\\n        return 0.0\\n    end\\nend\\n\\nfunction get_decimals_generic(token_contract_address::String, connection::Dict)::Int\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    # ERC20 decimals() function signature: 0x313ce567\\n    data = \\\"0x313ce567\\\"\\n    hex_result = eth_call_generic(token_contract_address, data, connection)\\n    if hex_result == \\\"0x\\\" || isempty(hex_result) || length(hex_result) <=2\\n        @warn \\\"get_decimals_generic eth_call returned empty/invalid result for \\$token_contract_address on \\$(connection[\\\"network\\\"]). Assuming 18.\\\"\\n        return 18 # Common default, but risky\\n    end\\n    return parse(Int, hex_result[3:end], base=16)\\nend\\n\\nfunction eth_call_generic(to_address::String, data::String, connection::Dict)\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    if !startswith(data, \\\"0x\\\") data = \\\"0x\\\" * data end\\n    \\n    params = [Dict(\\\"to\\\" => to_address, \\\"data\\\" => data), \\\"latest\\\"]\\n    return _make_generic_rpc_request(connection[\\\"endpoint\\\"], \\\"eth_call\\\", params)\\nend\\n\\n# --- Placeholders for other generic functions ---\\n\\nfunction get_gas_price_generic(connection::Dict)::Float64\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # Solana uses a different fee mechanism (lamports per signature, priority fees)\\n            # This is a simplification; real fee estimation is more complex.\\n            # getRecentPrioritizationFees can be used for priority fees.\\n            # getFees for base fee.\\n            result = _make_generic_rpc_request(endpoint, \\\"getFees\\\", [])\\n            # Example: result.value.feeCalculator.lamportsPerSignature\\n            return get(get(get(result,\\\"value\\\",Dict()),\\\"feeCalculator\\\",Dict()),\\\"lamportsPerSignature\\\", 5000) / 1_000_000_000 # Convert to SOL\\n        else # Assume EVM\\n            hex_gas_price = _make_generic_rpc_request(endpoint, \\\"eth_gasPrice\\\", [])\\n            gas_price_wei = parse(BigInt, hex_gas_price[3:end], base=16)\\n            return Float64(gas_price_wei / BigInt(10)^9) # Convert to Gwei\\n        end\\n    catch e\\n        @error \\\"Error getting gas price for \\$network\\\" error=e\\n        return 0.0 # Fallback\\n    end\\nend\\n\\nfunction get_transaction_count_generic(address::String, connection::Dict; block_tag::String=\\\"latest\\\")::Int\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # Solana doesn't have a direct nonce concept like EVM.\\n            # Transaction ordering is based on recent blockhash and leader schedule.\\n            # For some operations, one might query account info for sequence numbers if applicable.\\n            @warn \\\"get_transaction_count_generic: Solana does not use EVM-style nonces. Returning 0.\\\"\\n            return 0 \\n        else # Assume EVM\\n            hex_nonce = _make_generic_rpc_request(endpoint, \\\"eth_getTransactionCount\\\", [address, block_tag])\\n            return parse(Int, hex_nonce[3:end], base=16)\\n        end\\n    catch e\\n        @error \\\"Error getting transaction count for \\$address on \\$network\\\" error=e\\n        return -1 # Indicate error\\n    end\\nend\\n\\nfunction estimate_gas_generic(tx_params::Dict, connection::Dict)::Int\\n    # tx_params for EVM: {\\\"from\\\": \\\"0x...\\\", \\\"to\\\": \\\"0x...\\\", \\\"value\\\": \\\"0x...\\\", \\\"data\\\": \\\"0x...\\\"}\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # Solana gas/fee estimation is different. `getFeeForMessage` is used with a compiled message.\\n            # This is a highly simplified placeholder.\\n            @warn \\\"estimate_gas_generic for Solana is a placeholder. Real fee estimation is complex.\\\"\\n            return 5000 # Placeholder compute units * some factor\\n        else # Assume EVM\\n            # Ensure essential fields for EVM estimateGas\\n            if !haskey(tx_params, \\\"to\\\") \\n                error(\\\"Missing 'to' field in tx_params for EVM estimateGas\\\")\\n            end\\n            # 'from' is optional for eth_estimateGas but often good to include if known\\n            # 'value' defaults to 0x0 if not present\\n            # 'data' defaults to 0x if not present\\n            call_obj = Dict{String, String}()\\n            for (k,v) in tx_params\\n                if k in [\\\"from\\\", \\\"to\\\", \\\"value\\\", \\\"data\\\", \\\"gas\\\", \\\"gasPrice\\\"] # Common fields\\n                    call_obj[k] = v\\n                end\\n            end\\n\\n            hex_gas_estimate = _make_generic_rpc_request(endpoint, \\\"eth_estimateGas\\\", [call_obj])\\n            estimated_gas = parse(Int, hex_gas_estimate[3:end], base=16)\\n            # It's common to add a buffer to the estimate\\n            return Int(ceil(estimated_gas * 1.2)) \\n        end\\n    catch e\\n        @error \\\"Error estimating gas on \\$network\\\" error=e tx_params=tx_params\\n        return -1 # Indicate error\\n    end\\nend\\n\\n\\\"\\\"\\\"\\nfunction send_raw_transaction_generic(signed_tx_hex::String, connection::Dict)::String\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # For Solana, signed_tx_hex is typically base64 encoded string of the serialized transaction\\n            # The RPC method is \\\"sendTransaction\\\"\\n            # params: [signed_tx_base64_string, {\\\"encoding\\\": \\\"base64\\\", \\\"skipPreflight\\\": false, \\\"preflightCommitment\\\": \\\"confirmed\\\"}]\\n            # This is a placeholder, actual encoding and params might vary.\\n            @warn \\\"send_raw_transaction_generic for Solana: Ensure signed_tx_hex is base64 encoded.\\\"\\n            # Assuming signed_tx_hex is already base64 for Solana\\n            tx_hash = _make_generic_rpc_request(endpoint, \\\"sendTransaction\\\", [signed_tx_hex, Dict(\\\"encoding\\\"=>\\\"base64\\\")])\\n            return tx_hash # Returns transaction signature\\n        else # Assume EVM\\n            if !startswith(signed_tx_hex, \\\"0x\\\")\\n                error(\\\"EVM signed transaction hex must start with 0x\\\")\\n            end\\n            tx_hash = _make_generic_rpc_request(endpoint, \\\"eth_sendRawTransaction\\\", [signed_tx_hex])\\n            return tx_hash # Returns transaction hash\\n        end\\n    catch e\\n        @error \\\"Error sending raw transaction on \\$network\\\" error=e\\n        rethrow(e)\\n    end\\nend\\n\\nfunction get_transaction_receipt_generic(tx_hash::String, connection::Dict)::Union{Dict, Nothing}\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # Solana uses \\\"getTransaction\\\" with specific configuration for verbosity\\n            # The structure of a Solana receipt (TransactionResponse) is very different from EVM.\\n            # params: [tx_hash_string, {\\\"encoding\\\": \\\"jsonParsed\\\", \\\"maxSupportedTransactionVersion\\\": 0, \\\"commitment\\\": \\\"confirmed\\\"}]\\n            @warn \\\"get_transaction_receipt_generic for Solana: Response structure differs significantly from EVM.\\\"\\n            receipt = _make_generic_rpc_request(endpoint, \\\"getTransaction\\\", [tx_hash, \\\"jsonParsed\\\"]) # Or Dict for config\\n            return receipt # This will be a complex object\\n        else # Assume EVM\\n            receipt = _make_generic_rpc_request(endpoint, \\\"eth_getTransactionReceipt\\\", [tx_hash])\\n            return receipt # Can be nothing if tx is pending or not found\\n        end\\n    catch e\\n        # If RPC error indicates \\\"not found\\\" or similar, it might be valid for a pending/unknown tx.\\n        # For now, log and rethrow. Specific handling might be needed.\\n        @error \\\"Error getting transaction receipt for \\$tx_hash on \\$network\\\" error=e\\n        # Consider returning nothing or a specific error type instead of rethrowing for \\\"not found\\\" cases.\\n        if occursin(\\\"not found\\\", lowercase(sprint(showerror, e))) # Basic check\\n            return nothing\\n        end\\n        rethrow(e)\\n    end\\nend\\n\\n\\n@info \\\"Blockchain module (re)loaded with updated generic functions.\\\"\\n\\nend # module Blockchain\\n\", 0, \"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\Blockchain.jl\", 1, [1, 5, 73, 74, 153, 209, 213, 231, 232, 282, 283, 335, 339, 413, 473, 547, 555, 666, 735, 760, 799, 846, 854, 858, 859, 915, 998, 1107, 1206, 1298, 1299, 1370, 1393, 1492, 1493, 1579, 1705, 1786, 1860, 1861, 1945, 1946, 2061, 2062, 2097, 2177, 2182, 2211, 2326, 2395, 2410, 2418, 2419, 2494, 2607, 2701, 2822, 2823, 2876, 2877, 2942, 2989, 3068, 3077, 3192, 3249, 3366, 3367, 3395, 3555, 3576, 3588, 3597, 3697, 3746, 3802, 3861, 3917, 3971, 4031, 4082, 4137, 4218, 4274, 4299, 4308, 4415, 4423, 4428, 4551, 4628, 4688, 4840, 4897, 4982, 5047, 5161, 5310, 5425, 5441, 5453, 5461, 5462, 5508, 5662, 5666, 5667, 5749, 5780, 5873, 5918, 5974, 6017, 6019, 6020, 6040, 6111, 6115, 6116, 6206, 6246, 6285, 6335, 6419, 6480, 6519, 6576, 6618, 6634, 6646, 6669, 6677, 6696, 6700, 6701, 6772, 6812, 6847, 6890, 6914, 6926, 6934, 6953, 6957, 6958, 6959, 6963, 7050, 7051, 7121, 7177, 7181, 7273, 7316, 7321, 7374, 7395, 7404, 7448, 7456, 7457, 7494, 7580, 7719, 7727, 7728, 7808, 7813, 7864, 7949, 7961, 8014, 8135, 8195, 8211, 8311, 8323, 8331, 8332, 8349, 8389, 8431, 8466, 8558, 8598, 8604, 8608, 8609, 8672, 8768, 8793, 8821, 8851, 8879, 8906, 8912, 8920, 8950, 8976, 9028, 9067, 9110, 9120, 9178, 9187, 9229, 9275, 9424, 9474, 9551, 9563, 9599, 9611, 9724, 9769, 9777, 9781, 9782, 9833, 9914, 9915, 9998, 10006, 10042, 10085, 10163, 10197, 10234, 10321, 10379, 10391, 10403, 10487, 10508, 10516, 10520, 10521, 10574, 10629, 10725, 10730, 10771, 10838, 10925, 10980, 11100, 11119, 11127, 11151, 11239, 11291, 11295, 11296, 11297, 11370, 11466, 11502, 11540, 11541, 11549, 11580, 11662, 11756, 11826, 11852, 11952, 12020, 12091, 12103, 12115, 12187, 12217, 12225, 12229, 12230, 12348, 12433, 12469, 12507, 12508, 12516, 12547, 12590, 12700, 12800, 12848, 12942, 13056, 13150, 13218, 13255, 13287, 13357, 13443, 13492, 13505, 13590, 13669, 13682, 13715, 13801, 13879, 13891, 13903, 14019, 14038, 14046, 14050, 14051, 14136, 14221, 14275, 14299, 14375, 14450, 14596, 14642, 14650, 14700, 14704, 14705, 14783, 14868, 14922, 14927, 14993, 15074, 15078, 15079, 15130, 15131, 15189, 15274, 15310, 15348, 15356, 15387, 15479, 15556, 15629, 15665, 15737, 15808, 15949, 15975, 16059, 16132, 16207, 16219, 16231, 16293, 16323, 16331, 16335, 16336, 16443, 16528, 16564, 16602, 16610, 16641, 16708, 16793, 16893, 16995, 17017, 17043, 17152, 17209, 17221, 17233, 17315, 17350, 17358, 17362, 17363, 17433, 17526, 17611, 17647, 17685, 17693, 17724, 17830, 17885, 17987, 18053, 18079, 18137, 18178, 18255, 18271, 18359, 18412, 18463, 18509, 18544, 18635, 18671, 18691, 18707, 18708, 18806, 18879, 18937, 18988, 19000, 19012, 19090, 19125, 19133, 19137, 19138, 19142, 19229, 19314, 19350, 19388, 19396, 19427, 19532, 19582, 19714, 19790, 19891, 19957, 20079, 20138, 20164, 20212, 20283, 20299, 20400, 20454, 20466, 20478, 20545, 20564, 20572, 20576, 20577, 20675, 20760, 20796, 20834, 20842, 20873, 20958, 21056, 21187, 21302, 21424, 21483, 21509, 21607, 21681, 21693, 21705, 21806, 21877, 21961, 22068, 22148, 22175, 22187, 22206, 22214, 22218, 22219, 22220, 22289, 22290, 22314]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(22314, 22313, :error, \"unterminated string literal\"), Base.JuliaSyntax.Diagnostic(22314, 22313, :error, \"Expected `end`\")], :string))))","ok":false,"file":"test_address_validation.jl","seconds":2.6110000610351562},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\blockchain\\\\test_solana_rpc.jl\", 68, Some tests did not pass: 13 passed, 4 failed, 6 errored, 0 broken.)","ok":false,"file":"test_solana_rpc.jl","seconds":20.138000011444092},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\blockchain\\\\test_transaction_parser.jl\", 20, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\Blockchain.jl\", 472, Base.Meta.ParseError(\"ParseError:\\n# Error @ C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\Blockchain.jl:472:25\\n\\nend # module Blockchain\\n#                      \\nâ”” â”€â”€ unterminated string literal\", Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(\"\\\"\\\"\\\"\\nBlockchain.jl - Core module for blockchain interactions in JuliaOS.\\n\\nProvides a unified interface for interacting with various blockchain networks,\\nincluding EVM-compatible chains and others like Solana.\\n\\\"\\\"\\\"\\nmodule Blockchain\\n\\nusing HTTP, JSON3, Dates, Base64, Printf, Logging\\n\\n# Include the main application configuration module\\ntry\\n    include(\\\"../config/config.jl\\\") # Path from src/blockchain/ to config/\\n    MainAppConfig = Config # Alias the loaded Config module\\n    @info \\\"Blockchain.jl: Successfully included main application config.\\\"\\ncatch e\\n    @error \\\"Blockchain.jl: Failed to include main application config. Will use internal defaults.\\\" exception=e\\n    # Define a fallback AppConfigModule if main config fails to load\\n    module MainAppConfig\\n        load() = nothing # Placeholder\\n        get_value(cfg, key, default) = default\\n    end\\nend\\n\\n# Include submodules or specific client implementations\\ninclude(\\\"EthereumClient.jl\\\") # Assuming EthereumClient.jl is in the same directory\\n# Wallet.jl is simplified and no longer directly used for signing by Blockchain.jl's core generic functions.\\n# If any utility from Wallet.jl (like address validation) were needed, it could be `using .Wallet`\\n# but for now, its primary role (dev wallet object) is not used by these generic functions.\\n\\n# Re-export key functionalities from submodules if they are namespaced\\nusing .EthereumClient \\n# using .Wallet # Not strictly needed if Blockchain.jl doesn't use Wallet types/functions directly\\n\\nexport connect, get_balance, get_transaction_receipt_generic, is_node_healthy_generic\\nexport get_chain_id_generic, get_gas_price_generic, get_token_balance_generic, send_raw_transaction_generic, eth_call_generic\\nexport get_transaction_count_generic, estimate_gas_generic, get_decimals_generic\\nexport SUPPORTED_CHAINS_CONFIG, get_rpc_endpoint, get_chain_name_from_id \\n\\n# Configuration for supported blockchain networks will be loaded from MainAppConfig\\n\\nconst SUPPORTED_CHAINS_CONFIG = Ref(Dict{String, Dict{String,Any}}()) # To be populated by _load_blockchain_config\\n\\nfunction _load_blockchain_config()\\n    app_config = MainAppConfig.load() # Load the main application configuration\\n    \\n    if isnothing(app_config)\\n        @error \\\"Blockchain.jl: Main application configuration could not be loaded. Using empty blockchain config.\\\"\\n        SUPPORTED_CHAINS_CONFIG[] = Dict{String, Dict{String,Any}}()\\n        return\\n    end\\n\\n    # Get RPC URLs and supported chains from the loaded application config\\n    # The paths like \\\"blockchain.rpc_urls\\\" are based on the structure in julia/config/config.jl's DEFAULT_CONFIG\\n    rpc_urls_from_config = MainAppConfig.get_value(app_config, \\\"blockchain.rpc_urls\\\", Dict())\\n    supported_chains_list = MainAppConfig.get_value(app_config, \\\"blockchain.supported_chains\\\", []) # List of chain names\\n\\n    loaded_config = Dict{String, Dict{String,Any}}()\\n\\n    # Prioritize chains listed in \\\"supported_chains\\\" from config\\n    for chain_key_any in supported_chains_list\\n        chain_key = lowercase(string(chain_key_any)) # Ensure lowercase string\\n        \\n        # Get RPC URL: ENV variable > config file's rpc_urls section > hardcoded DEFAULT_RPC_URLS (as last resort)\\n        env_var_name = uppercase(chain_key) * \\\"_RPC_URL\\\"\\n        rpc_url = get(ENV, env_var_name, get(rpc_urls_from_config, chain_key, get(DEFAULT_RPC_URLS, chain_key, \\\"\\\")))\\n\\n        if isempty(rpc_url)\\n            @warn \\\"No RPC URL found for supported chain: \\$chain_key (checked ENV.\\$env_var_name, config.blockchain.rpc_urls.\\$chain_key, and internal defaults).\\\"\\n            continue\\n        end\\n        \\n        # Chain ID mapping (can be expanded or made configurable, or fetched from node if possible)\\n        chain_id = if chain_key == \\\"ethereum\\\"; 1\\n                     elseif chain_key == \\\"polygon\\\"; 137\\n                     elseif chain_key == \\\"arbitrum\\\"; 42161\\n                     elseif chain_key == \\\"optimism\\\"; 10\\n                     elseif chain_key == \\\"base\\\"; 8453\\n                     elseif chain_key == \\\"avalanche\\\"; 43114\\n                     elseif chain_key == \\\"bsc\\\"; 56\\n                     elseif chain_key == \\\"fantom\\\"; 250\\n                     elseif chain_key == \\\"solana\\\"; -1 # Special value for Solana\\n                     else; 0 # Unknown or to be fetched\\n                     end\\n        \\n        loaded_config[chain_key] = Dict(\\\"rpc_url\\\" => rpc_url, \\\"chain_id\\\" => chain_id, \\\"name\\\" => chain_key)\\n    end\\n    \\n    # Fallback for any chains in DEFAULT_RPC_URLS not covered by supported_chains_list (e.g. if supported_chains is empty)\\n    # This ensures some level of default functionality if config is minimal.\\n    if isempty(loaded_config) && !isempty(DEFAULT_RPC_URLS)\\n        @warn \\\"blockchain.supported_chains list in config was empty or resulted in no valid configurations. Falling back to internal DEFAULT_RPC_URLS.\\\"\\n        for (chain_key, default_url) in DEFAULT_RPC_URLS\\n            if !haskey(loaded_config, chain_key) # Add only if not already processed\\n                env_var_name = uppercase(chain_key) * \\\"_RPC_URL\\\"\\n                rpc_url = get(ENV, env_var_name, default_url) # ENV still takes precedence over hardcoded default\\n                chain_id = if chain_key == \\\"ethereum\\\"; 1 elseif chain_key == \\\"polygon\\\"; 137 elseif chain_key == \\\"solana\\\"; -1 else 0 end # Simplified\\n                loaded_config[chain_key] = Dict(\\\"rpc_url\\\" => rpc_url, \\\"chain_id\\\" => chain_id, \\\"name\\\" => chain_key)\\n            end\\n        end\\n    end\\n\\n    SUPPORTED_CHAINS_CONFIG[] = loaded_config\\n    @info \\\"Blockchain configuration initialized with \\$(length(SUPPORTED_CHAINS_CONFIG[])) chains from main application config and environment variables.\\\"\\nend\\n\\n# Define DEFAULT_RPC_URLS here as a fallback if config system fails or is minimal\\nconst DEFAULT_RPC_URLS = Dict(\\n    \\\"ethereum\\\" => \\\"https://mainnet.infura.io/v3/YOUR_INFURA_KEY\\\", # User should replace this\\n    \\\"polygon\\\"  => \\\"https://polygon-rpc.com\\\",\\n    \\\"solana\\\"   => \\\"https://api.mainnet-beta.solana.com\\\"\\n    # Add other common defaults if desired\\n)\\n\\nfunction __init__()\\n    _load_blockchain_config() # Load config when module is initialized\\nend\\n\\nfunction get_rpc_endpoint(network_name_or_id::Union{String, Int})::Union{String, Nothing}\\n    configs = SUPPORTED_CHAINS_CONFIG[]\\n    if isa(network_name_or_id, String)\\n        norm_name = lowercase(network_name_or_id)\\n        return haskey(configs, norm_name) ? configs[norm_name][\\\"rpc_url\\\"] : nothing\\n    elseif isa(network_name_or_id, Int) # Lookup by chain_id\\n        for (name, details) in configs\\n            if details[\\\"chain_id\\\"] == network_name_or_id\\n                return details[\\\"rpc_url\\\"]\\n            end\\n        end\\n        return nothing\\n    end\\n    return nothing\\nend\\n\\nfunction get_chain_name_from_id(chain_id::Int)::Union{String, Nothing}\\n    configs = SUPPORTED_CHAINS_CONFIG[]\\n    for (name, details) in configs\\n        if details[\\\"chain_id\\\"] == chain_id\\n            return name\\n        end\\n    end\\n    return nothing\\nend\\n\\n\\n\\\"\\\"\\\"\\n    connect(; network::String=\\\"ethereum\\\", endpoint_url::Union{String,Nothing}=nothing)\\n\\nEstablishes and tests a connection to a specified blockchain network.\\nReturns a dictionary representing the connection state.\\n\\\"\\\"\\\"\\nfunction connect(; network::String=\\\"ethereum\\\", endpoint_url::Union{String,Nothing}=nothing)\\n    norm_network_name = lowercase(network)\\n    \\n    final_endpoint_url = if !isnothing(endpoint_url)\\n        endpoint_url\\n    else\\n        get_rpc_endpoint(norm_network_name)\\n    end\\n\\n    if isnothing(final_endpoint_url)\\n        @error \\\"No RPC endpoint configured or found for network: \\$norm_network_name.\\\"\\n        return Dict(\\\"network\\\" => norm_network_name, \\\"endpoint\\\" => nothing, \\\"connected\\\" => false, \\\"error\\\" => \\\"RPC endpoint not configured\\\")\\n    end\\n\\n    is_healthy = is_node_healthy_generic(norm_network_name, final_endpoint_url)\\n    \\n    chain_id = -1 # Default for unknown or non-EVM\\n    if is_healthy && norm_network_name != \\\"solana\\\" # Solana doesn't have eth_chainId\\n        try\\n            # Attempt to get chain_id for EVM chains\\n            temp_conn_dict = Dict(\\\"network\\\" => norm_network_name, \\\"endpoint\\\" => final_endpoint_url, \\\"connected\\\" => true)\\n            chain_id = get_chain_id_generic(temp_conn_dict)\\n        catch e\\n            @warn \\\"Could not fetch chain_id for \\$norm_network_name via \\$final_endpoint_url\\\" error=e\\n        end\\n    end\\n\\n    return Dict(\\n        \\\"network\\\" => norm_network_name,\\n        \\\"endpoint\\\" => final_endpoint_url,\\n        \\\"connected\\\" => is_healthy,\\n        \\\"chain_id_retrieved\\\" => chain_id, # May differ from configured if endpoint is wrong\\n        \\\"timestamp\\\" => string(now(UTC))\\n    )\\nend\\n\\n# Generic RPC request helper (primarily for EVM-like JSON-RPC)\\nfunction _make_generic_rpc_request(endpoint_url::String, method::String, params::AbstractArray)\\n    request_body = Dict(\\n        \\\"jsonrpc\\\" => \\\"2.0\\\",\\n        \\\"id\\\" => rand(UInt32),\\n        \\\"method\\\" => method,\\n        \\\"params\\\" => params\\n    )\\n    try\\n        response = HTTP.post(\\n            endpoint_url,\\n            [\\\"Content-Type\\\" => \\\"application/json\\\"],\\n            JSON3.write(request_body);\\n            timeout = 20 # Default timeout\\n        )\\n        response_json = JSON3.read(String(response.body))\\n        \\n        if haskey(response_json, \\\"error\\\")\\n            err_details = response_json.error\\n            err_msg = \\\"RPC Error for method \\$method: \\$(get(err_details, \\\"message\\\", \\\"Unknown RPC error\\\")) (Code: \\$(get(err_details, \\\"code\\\", \\\"N/A\\\")))\\\"\\n            @error err_msg full_error=err_details\\n            error(err_msg) # Throw an error to be caught by calling function\\n        end\\n        return response_json.result\\n    catch e\\n        @error \\\"Generic RPC request failed for method \\$method to \\$endpoint_url\\\" exception=(e, catch_backtrace())\\n        rethrow(e) # Propagate the exception\\n    end\\nend\\n\\n# --- Generic Blockchain Interaction Functions ---\\n# These will delegate to chain-specific implementations or use generic JSON-RPC.\\n\\nfunction is_node_healthy_generic(network_name::String, endpoint_url::String)::Bool\\n    try\\n        if network_name == \\\"solana\\\"\\n            # Solana-specific health check\\n            result = _make_generic_rpc_request(endpoint_url, \\\"getHealth\\\", [])\\n            return result == \\\"ok\\\"\\n        else # Assume EVM-compatible\\n            result = _make_generic_rpc_request(endpoint_url, \\\"web3_clientVersion\\\", [])\\n            return !isnothing(result) && !isempty(result)\\n        end\\n    catch e\\n        @warn \\\"Node health check failed for \\$network_name at \\$endpoint_url\\\" error=e\\n        return false\\n    end\\nend\\n\\nfunction get_chain_id_generic(connection::Dict)::Int\\n    # `connection` is the Dict returned by `connect()`\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected to network: \\$(connection[\\\"network\\\"])\\\") end\\n    \\n    if connection[\\\"network\\\"] == \\\"solana\\\"\\n        # Solana doesn't have a numeric chain ID in the EVM sense.\\n        # Mainnet-beta, Testnet, Devnet are identified by cluster URL or genesis hash.\\n        # We can return a conventional value or error.\\n        @warn \\\"get_chain_id_generic: Solana does not use numeric chain IDs like EVM chains. Returning conventional -1.\\\"\\n        return -1 \\n    end\\n    # Assumes EVM chain\\n    hex_chain_id = _make_generic_rpc_request(connection[\\\"endpoint\\\"], \\\"eth_chainId\\\", [])\\n    return parse(Int, hex_chain_id[3:end], base=16)\\nend\\n\\n\\nfunction get_balance_generic(address::String, connection::Dict)::Float64\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected to network: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n\\n    try\\n        if network == \\\"solana\\\"\\n            result = _make_generic_rpc_request(endpoint, \\\"getBalance\\\", [address])\\n            balance_lamports = result[\\\"value\\\"] # result is Dict(\\\"context\\\"=>..., \\\"value\\\"=>...)\\n            return balance_lamports / 1_000_000_000 # Lamports to SOL\\n        else # Assume EVM\\n            hex_result = _make_generic_rpc_request(endpoint, \\\"eth_getBalance\\\", [address, \\\"latest\\\"])\\n            balance_wei = parse(BigInt, hex_result[3:end], base=16)\\n            return Float64(balance_wei / BigInt(10)^18) # Wei to Ether\\n        end\\n    catch e\\n        @error \\\"Error getting balance for \\$address on \\$network\\\" error=e\\n        return 0.0 # Fallback\\n    end\\nend\\n\\nfunction get_token_balance_generic(wallet_address::String, token_contract_address::String, connection::Dict)::Float64\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n\\n    try\\n        if network == \\\"solana\\\"\\n            # SPL Token Balance for Solana\\n            # This requires knowing the token's mint address and the associated token account for the wallet.\\n            # A common approach is to use `getTokenAccountsByOwner` then find the one for the mint.\\n            # This is a simplified placeholder.\\n            @warn \\\"get_token_balance_generic for Solana SPL tokens is a complex placeholder.\\\"\\n            # params = [wallet_address, Dict(\\\"mint\\\" => token_contract_address), Dict(\\\"encoding\\\" => \\\"jsonParsed\\\")]\\n            # result = _make_generic_rpc_request(endpoint, \\\"getTokenAccountsByOwner\\\", params)\\n            # if !isempty(result[\\\"value\\\"]) ... parse result ... end\\n            return 0.0 # Placeholder\\n        else # Assume EVM ERC20\\n            # ERC20 balanceOf(address) function signature: 0x70a08231\\n            padded_address = lpad(wallet_address[3:end], 64, '0') # Remove 0x and pad\\n            data = \\\"0x70a08231\\\" * padded_address\\n            \\n            hex_balance = eth_call_generic(token_contract_address, data, connection)\\n            balance_smallest_unit = parse(BigInt, hex_balance[3:end], base=16)\\n            \\n            # Get token decimals\\n            token_decimals = get_decimals_generic(token_contract_address, connection)\\n            return Float64(balance_smallest_unit / BigInt(10)^token_decimals)\\n        end\\n    catch e\\n        @error \\\"Error getting token balance for \\$wallet_address, token \\$token_contract_address on \\$network\\\" error=e\\n        return 0.0\\n    end\\nend\\n\\nfunction get_decimals_generic(token_contract_address::String, connection::Dict)::Int\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    # ERC20 decimals() function signature: 0x313ce567\\n    data = \\\"0x313ce567\\\"\\n    hex_result = eth_call_generic(token_contract_address, data, connection)\\n    if hex_result == \\\"0x\\\" || isempty(hex_result) || length(hex_result) <=2\\n        @warn \\\"get_decimals_generic eth_call returned empty/invalid result for \\$token_contract_address on \\$(connection[\\\"network\\\"]). Assuming 18.\\\"\\n        return 18 # Common default, but risky\\n    end\\n    return parse(Int, hex_result[3:end], base=16)\\nend\\n\\nfunction eth_call_generic(to_address::String, data::String, connection::Dict)\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    if !startswith(data, \\\"0x\\\") data = \\\"0x\\\" * data end\\n    \\n    params = [Dict(\\\"to\\\" => to_address, \\\"data\\\" => data), \\\"latest\\\"]\\n    return _make_generic_rpc_request(connection[\\\"endpoint\\\"], \\\"eth_call\\\", params)\\nend\\n\\n# --- Placeholders for other generic functions ---\\n\\nfunction get_gas_price_generic(connection::Dict)::Float64\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # Solana uses a different fee mechanism (lamports per signature, priority fees)\\n            # This is a simplification; real fee estimation is more complex.\\n            # getRecentPrioritizationFees can be used for priority fees.\\n            # getFees for base fee.\\n            result = _make_generic_rpc_request(endpoint, \\\"getFees\\\", [])\\n            # Example: result.value.feeCalculator.lamportsPerSignature\\n            return get(get(get(result,\\\"value\\\",Dict()),\\\"feeCalculator\\\",Dict()),\\\"lamportsPerSignature\\\", 5000) / 1_000_000_000 # Convert to SOL\\n        else # Assume EVM\\n            hex_gas_price = _make_generic_rpc_request(endpoint, \\\"eth_gasPrice\\\", [])\\n            gas_price_wei = parse(BigInt, hex_gas_price[3:end], base=16)\\n            return Float64(gas_price_wei / BigInt(10)^9) # Convert to Gwei\\n        end\\n    catch e\\n        @error \\\"Error getting gas price for \\$network\\\" error=e\\n        return 0.0 # Fallback\\n    end\\nend\\n\\nfunction get_transaction_count_generic(address::String, connection::Dict; block_tag::String=\\\"latest\\\")::Int\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # Solana doesn't have a direct nonce concept like EVM.\\n            # Transaction ordering is based on recent blockhash and leader schedule.\\n            # For some operations, one might query account info for sequence numbers if applicable.\\n            @warn \\\"get_transaction_count_generic: Solana does not use EVM-style nonces. Returning 0.\\\"\\n            return 0 \\n        else # Assume EVM\\n            hex_nonce = _make_generic_rpc_request(endpoint, \\\"eth_getTransactionCount\\\", [address, block_tag])\\n            return parse(Int, hex_nonce[3:end], base=16)\\n        end\\n    catch e\\n        @error \\\"Error getting transaction count for \\$address on \\$network\\\" error=e\\n        return -1 # Indicate error\\n    end\\nend\\n\\nfunction estimate_gas_generic(tx_params::Dict, connection::Dict)::Int\\n    # tx_params for EVM: {\\\"from\\\": \\\"0x...\\\", \\\"to\\\": \\\"0x...\\\", \\\"value\\\": \\\"0x...\\\", \\\"data\\\": \\\"0x...\\\"}\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # Solana gas/fee estimation is different. `getFeeForMessage` is used with a compiled message.\\n            # This is a highly simplified placeholder.\\n            @warn \\\"estimate_gas_generic for Solana is a placeholder. Real fee estimation is complex.\\\"\\n            return 5000 # Placeholder compute units * some factor\\n        else # Assume EVM\\n            # Ensure essential fields for EVM estimateGas\\n            if !haskey(tx_params, \\\"to\\\") \\n                error(\\\"Missing 'to' field in tx_params for EVM estimateGas\\\")\\n            end\\n            # 'from' is optional for eth_estimateGas but often good to include if known\\n            # 'value' defaults to 0x0 if not present\\n            # 'data' defaults to 0x if not present\\n            call_obj = Dict{String, String}()\\n            for (k,v) in tx_params\\n                if k in [\\\"from\\\", \\\"to\\\", \\\"value\\\", \\\"data\\\", \\\"gas\\\", \\\"gasPrice\\\"] # Common fields\\n                    call_obj[k] = v\\n                end\\n            end\\n\\n            hex_gas_estimate = _make_generic_rpc_request(endpoint, \\\"eth_estimateGas\\\", [call_obj])\\n            estimated_gas = parse(Int, hex_gas_estimate[3:end], base=16)\\n            # It's common to add a buffer to the estimate\\n            return Int(ceil(estimated_gas * 1.2)) \\n        end\\n    catch e\\n        @error \\\"Error estimating gas on \\$network\\\" error=e tx_params=tx_params\\n        return -1 # Indicate error\\n    end\\nend\\n\\n\\\"\\\"\\\"\\nfunction send_raw_transaction_generic(signed_tx_hex::String, connection::Dict)::String\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # For Solana, signed_tx_hex is typically base64 encoded string of the serialized transaction\\n            # The RPC method is \\\"sendTransaction\\\"\\n            # params: [signed_tx_base64_string, {\\\"encoding\\\": \\\"base64\\\", \\\"skipPreflight\\\": false, \\\"preflightCommitment\\\": \\\"confirmed\\\"}]\\n            # This is a placeholder, actual encoding and params might vary.\\n            @warn \\\"send_raw_transaction_generic for Solana: Ensure signed_tx_hex is base64 encoded.\\\"\\n            # Assuming signed_tx_hex is already base64 for Solana\\n            tx_hash = _make_generic_rpc_request(endpoint, \\\"sendTransaction\\\", [signed_tx_hex, Dict(\\\"encoding\\\"=>\\\"base64\\\")])\\n            return tx_hash # Returns transaction signature\\n        else # Assume EVM\\n            if !startswith(signed_tx_hex, \\\"0x\\\")\\n                error(\\\"EVM signed transaction hex must start with 0x\\\")\\n            end\\n            tx_hash = _make_generic_rpc_request(endpoint, \\\"eth_sendRawTransaction\\\", [signed_tx_hex])\\n            return tx_hash # Returns transaction hash\\n        end\\n    catch e\\n        @error \\\"Error sending raw transaction on \\$network\\\" error=e\\n        rethrow(e)\\n    end\\nend\\n\\nfunction get_transaction_receipt_generic(tx_hash::String, connection::Dict)::Union{Dict, Nothing}\\n    if !connection[\\\"connected\\\"] error(\\\"Not connected: \\$(connection[\\\"network\\\"])\\\") end\\n    network = connection[\\\"network\\\"]\\n    endpoint = connection[\\\"endpoint\\\"]\\n    try\\n        if network == \\\"solana\\\"\\n            # Solana uses \\\"getTransaction\\\" with specific configuration for verbosity\\n            # The structure of a Solana receipt (TransactionResponse) is very different from EVM.\\n            # params: [tx_hash_string, {\\\"encoding\\\": \\\"jsonParsed\\\", \\\"maxSupportedTransactionVersion\\\": 0, \\\"commitment\\\": \\\"confirmed\\\"}]\\n            @warn \\\"get_transaction_receipt_generic for Solana: Response structure differs significantly from EVM.\\\"\\n            receipt = _make_generic_rpc_request(endpoint, \\\"getTransaction\\\", [tx_hash, \\\"jsonParsed\\\"]) # Or Dict for config\\n            return receipt # This will be a complex object\\n        else # Assume EVM\\n            receipt = _make_generic_rpc_request(endpoint, \\\"eth_getTransactionReceipt\\\", [tx_hash])\\n            return receipt # Can be nothing if tx is pending or not found\\n        end\\n    catch e\\n        # If RPC error indicates \\\"not found\\\" or similar, it might be valid for a pending/unknown tx.\\n        # For now, log and rethrow. Specific handling might be needed.\\n        @error \\\"Error getting transaction receipt for \\$tx_hash on \\$network\\\" error=e\\n        # Consider returning nothing or a specific error type instead of rethrowing for \\\"not found\\\" cases.\\n        if occursin(\\\"not found\\\", lowercase(sprint(showerror, e))) # Basic check\\n            return nothing\\n        end\\n        rethrow(e)\\n    end\\nend\\n\\n\\n@info \\\"Blockchain module (re)loaded with updated generic functions.\\\"\\n\\nend # module Blockchain\\n\", 0, \"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\Blockchain.jl\", 1, [1, 5, 73, 74, 153, 209, 213, 231, 232, 282, 283, 335, 339, 413, 473, 547, 555, 666, 735, 760, 799, 846, 854, 858, 859, 915, 998, 1107, 1206, 1298, 1299, 1370, 1393, 1492, 1493, 1579, 1705, 1786, 1860, 1861, 1945, 1946, 2061, 2062, 2097, 2177, 2182, 2211, 2326, 2395, 2410, 2418, 2419, 2494, 2607, 2701, 2822, 2823, 2876, 2877, 2942, 2989, 3068, 3077, 3192, 3249, 3366, 3367, 3395, 3555, 3576, 3588, 3597, 3697, 3746, 3802, 3861, 3917, 3971, 4031, 4082, 4137, 4218, 4274, 4299, 4308, 4415, 4423, 4428, 4551, 4628, 4688, 4840, 4897, 4982, 5047, 5161, 5310, 5425, 5441, 5453, 5461, 5462, 5508, 5662, 5666, 5667, 5749, 5780, 5873, 5918, 5974, 6017, 6019, 6020, 6040, 6111, 6115, 6116, 6206, 6246, 6285, 6335, 6419, 6480, 6519, 6576, 6618, 6634, 6646, 6669, 6677, 6696, 6700, 6701, 6772, 6812, 6847, 6890, 6914, 6926, 6934, 6953, 6957, 6958, 6959, 6963, 7050, 7051, 7121, 7177, 7181, 7273, 7316, 7321, 7374, 7395, 7404, 7448, 7456, 7457, 7494, 7580, 7719, 7727, 7728, 7808, 7813, 7864, 7949, 7961, 8014, 8135, 8195, 8211, 8311, 8323, 8331, 8332, 8349, 8389, 8431, 8466, 8558, 8598, 8604, 8608, 8609, 8672, 8768, 8793, 8821, 8851, 8879, 8906, 8912, 8920, 8950, 8976, 9028, 9067, 9110, 9120, 9178, 9187, 9229, 9275, 9424, 9474, 9551, 9563, 9599, 9611, 9724, 9769, 9777, 9781, 9782, 9833, 9914, 9915, 9998, 10006, 10042, 10085, 10163, 10197, 10234, 10321, 10379, 10391, 10403, 10487, 10508, 10516, 10520, 10521, 10574, 10629, 10725, 10730, 10771, 10838, 10925, 10980, 11100, 11119, 11127, 11151, 11239, 11291, 11295, 11296, 11297, 11370, 11466, 11502, 11540, 11541, 11549, 11580, 11662, 11756, 11826, 11852, 11952, 12020, 12091, 12103, 12115, 12187, 12217, 12225, 12229, 12230, 12348, 12433, 12469, 12507, 12508, 12516, 12547, 12590, 12700, 12800, 12848, 12942, 13056, 13150, 13218, 13255, 13287, 13357, 13443, 13492, 13505, 13590, 13669, 13682, 13715, 13801, 13879, 13891, 13903, 14019, 14038, 14046, 14050, 14051, 14136, 14221, 14275, 14299, 14375, 14450, 14596, 14642, 14650, 14700, 14704, 14705, 14783, 14868, 14922, 14927, 14993, 15074, 15078, 15079, 15130, 15131, 15189, 15274, 15310, 15348, 15356, 15387, 15479, 15556, 15629, 15665, 15737, 15808, 15949, 15975, 16059, 16132, 16207, 16219, 16231, 16293, 16323, 16331, 16335, 16336, 16443, 16528, 16564, 16602, 16610, 16641, 16708, 16793, 16893, 16995, 17017, 17043, 17152, 17209, 17221, 17233, 17315, 17350, 17358, 17362, 17363, 17433, 17526, 17611, 17647, 17685, 17693, 17724, 17830, 17885, 17987, 18053, 18079, 18137, 18178, 18255, 18271, 18359, 18412, 18463, 18509, 18544, 18635, 18671, 18691, 18707, 18708, 18806, 18879, 18937, 18988, 19000, 19012, 19090, 19125, 19133, 19137, 19138, 19142, 19229, 19314, 19350, 19388, 19396, 19427, 19532, 19582, 19714, 19790, 19891, 19957, 20079, 20138, 20164, 20212, 20283, 20299, 20400, 20454, 20466, 20478, 20545, 20564, 20572, 20576, 20577, 20675, 20760, 20796, 20834, 20842, 20873, 20958, 21056, 21187, 21302, 21424, 21483, 21509, 21607, 21681, 21693, 21705, 21806, 21877, 21961, 22068, 22148, 22175, 22187, 22206, 22214, 22218, 22219, 22220, 22289, 22290, 22314]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(22314, 22313, :error, \"unterminated string literal\"), Base.JuliaSyntax.Diagnostic(22314, 22313, :error, \"Expected `end`\")], :string))))","ok":false,"file":"test_transaction_parser.jl","seconds":2.7220001220703125},{"error":null,"ok":true,"file":"test_mcp_clients.jl","seconds":13.707000017166138},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\mcp\\\\test_mcp_server.jl\", 813, Some tests did not pass: 104 passed, 9 failed, 8 errored, 0 broken.)","ok":false,"file":"test_mcp_server.jl","seconds":12.140000104904175}],"mode":"full","categories":{"agents":{"passed":2,"total":7},"api":{"passed":2,"total":8},"analysis":{"passed":8,"total":9},"tools":{"passed":1,"total":8},"blockchain":{"passed":0,"total":3},"mcp":{"passed":1,"total":2}},"generated_at":"2025-08-15T14:21:24","wall_seconds":405.39200019836426}