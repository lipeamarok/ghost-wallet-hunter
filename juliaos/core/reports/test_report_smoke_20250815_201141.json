{"summary":{"failed":12,"p99":21.728000164031982,"total":15,"p95":21.728000164031982,"passed":3},"files":[{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\analysis\\\\test_analysis_core.jl\", 16, Some tests did not pass: 22 passed, 0 failed, 8 errored, 1 broken.)","ok":false,"file":"test_analysis_core.jl","seconds":21.728000164031982},{"error":null,"ok":true,"file":"test_graph_builder.jl","seconds":21.42900013923645},{"error":null,"ok":true,"file":"test_explainability.jl","seconds":15.984999895095825},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\tools\\\\test_blacklist_checker.jl\", 31, Some tests did not pass: 44 passed, 0 failed, 1 errored, 0 broken.)","ok":false,"file":"test_blacklist_checker.jl","seconds":5.790999889373779},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\tools\\\\test_risk_assessment.jl\", 42, Some tests did not pass: 56 passed, 0 failed, 1 errored, 0 broken.)","ok":false,"file":"test_risk_assessment.jl","seconds":11.29699993133545},{"error":null,"ok":true,"file":"test_dupin_agent.jl","seconds":4.330999851226807},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\agents\\\\test_marple_agent.jl\", 433, Some tests did not pass: 35 passed, 2 failed, 1 errored, 0 broken.)","ok":false,"file":"test_marple_agent.jl","seconds":13.944000005722046},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\agents\\\\test_raven_agent.jl\", 37, Some tests did not pass: 1 passed, 0 failed, 9 errored, 0 broken.)","ok":false,"file":"test_raven_agent.jl","seconds":6.648999929428101},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\agents\\\\test_spade_agent.jl\", 481, Some tests did not pass: 49 passed, 2 failed, 0 errored, 0 broken.)","ok":false,"file":"test_spade_agent.jl","seconds":18.984999895095825},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_frontend_handlers.jl\", 655, Some tests did not pass: 143 passed, 1 failed, 0 errored, 0 broken.)","ok":false,"file":"test_frontend_handlers.jl","seconds":15.63100004196167},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\api\\\\test_metrics_handlers.jl\", 716, Some tests did not pass: 54 passed, 0 failed, 4 errored, 0 broken.)","ok":false,"file":"test_metrics_handlers.jl","seconds":2.1429998874664307},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\blockchain\\\\test_address_validation.jl\", 20, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\Blockchain.jl\", 1, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\EthereumClient.jl\", 62, Base.Meta.ParseError(\"ParseError:\\n# Error @ C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\EthereumClient.jl:62:5\\n        end\\n    elseif startswith(canonical_type, \\\"bytes\\\") && !endswith(canonical_type, \\\"[]\\\") # bytes1..bytes32\\n#   └ ── Expected `end`\", Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(\"\\\"\\\"\\\"\\nEthereumClient.jl - Ethereum blockchain client for JuliaOS\\n\\nThis module provides specific functionality for interacting with Ethereum\\nand other EVM-compatible blockchains. It builds upon generic RPC calls\\nand provides higher-level abstractions.\\n\\\"\\\"\\\"\\nmodule EthereumClient\\n\\nusing HTTP, JSON3, Dates, Base64, Printf, Logging\\n# Assuming Blockchain.jl (which might contain _make_generic_rpc_request) is accessible\\n# This might need adjustment based on how modules are structured and loaded.\\n# If Blockchain.jl `include`s this file, then _make_generic_rpc_request is in its scope.\\n# If this is a standalone submodule, it might need to import from a parent Blockchain module.\\n\\nexport EthereumConfig, EthereumProvider, create_ethereum_provider\\nexport call_contract_evm, send_transaction_evm, get_balance_evm, get_block_by_number_evm, get_transaction_by_hash_evm\\nexport get_nonce_evm, estimate_gas_evm\\nexport encode_function_call_abi, decode_function_result_abi # More ABI-aware versions\\nexport eth_to_wei_str, wei_to_eth_float # Renamed for clarity\\n\\n\\\"\\\"\\\"\\n    EthereumConfig\\n\\nConfiguration for an Ethereum/EVM client.\\n(This might be duplicative if Blockchain.jl's connection Dict holds this info.\\n Consider if this struct is needed or if connection Dict is sufficient.)\\n\\\"\\\"\\\"\\nstruct EthereumConfig\\n    rpc_url::String\\n    chain_id::Int\\n    # private_key::String # Private keys should be handled by a secure wallet/signer service, not here.\\n    default_gas_limit::Int\\n    default_gas_price_gwei::Float64 # In Gwei\\n    timeout_seconds::Int\\n    \\n    function EthereumConfig(;\\n        rpc_url::String,\\n        chain_id::Int = 1, # Default to Ethereum Mainnet\\n        default_gas_limit::Int = 300_000,\\n        default_gas_price_gwei::Float64 = 20.0, # Gwei\\n        timeout_seconds::Int = 30\\n    )\\n        new(rpc_url, chain_id, default_gas_limit, default_gas_price_gwei, timeout_seconds)\\n    end\\nend\\n\\n\\\"\\\"\\\"\\n    EthereumProvider\\n\\nRepresents a connection and configuration for an EVM chain.\\nThe `connection_dict` is the structure returned by `Blockchain.connect()`.\\n\\\"\\\"\\\"\\nstruct EthereumProvider\\n    config::EthereumConfig # Contains defaults like gas price, limit\\n    connection_dict::Dict{String, Any} # Contains rpc_url, chain_id, connected status\\n\\n    function EthereumProvider(config::EthereumConfig, connection_dict::Dict{String,Any})\\n        if !connection_dict[\\\"connected\\\"]\\n            error(\\\"Cannot create EthereumProvider with a disconnected connection.\\\")\\n        end\\n    elseif startswith(canonical_type, \\\"bytes\\\") && !endswith(canonical_type, \\\"[]\\\") # bytes1..bytes32\\n        len_match = match(r\\\"bytes(\\\\d+)\\\", canonical_type)\\n        if !isnothing(len_match) && isa(value, Vector{UInt8})\\n            num_bytes = parse(Int, len_match.captures[1])\\n            if length(value) > num_bytes error(\\\"Data for bytes\\$num_bytes is too long: \\$(length(value)) bytes\\\") end\\n            return rpad(bytes2hex(value), 64, '0') # bytesN are left-aligned\\n        else\\n            error(\\\"Invalid value for bytesN type '\\$canonical_type' or value type '\\$(typeof(value))'. Expected Vector{UInt8}.\\\")\\n        end\\n    elseif startswith(canonical_type, \\\"(\\\") && endswith(canonical_type, \\\")\\\") # Static Tuple/Struct\\n        if !isa(value, Tuple) && !isa(value, AbstractVector)\\n            error(\\\"Argument for static tuple/struct type \\$canonical_type must be a Tuple or Vector. Got \\$(typeof(value))\\\")\\n        end\\n        element_types_str_content = canonical_type[2:end-1]\\n        element_type_strs = []\\n        balance = 0; current_type = \\\"\\\"\\n        for char in element_types_str_content\\n            if char == '(' balance +=1 elseif char == ')' balance -=1 end\\n            if char == ',' && balance == 0\\n                push!(element_type_strs, strip(current_type)); current_type = \\\"\\\"\\n            else current_type *= char end\\n        end\\n        push!(element_type_strs, strip(current_type))\\n\\n        if length(value) != length(element_type_strs)\\n            error(\\\"Number of values in static tuple/struct (\\$(length(value))) does not match types in signature (\\$canonical_type -> \\$(length(element_type_strs)))\\\")\\n        end\\n\\n        encoded_elements = \\\"\\\"\\n        for (idx, elem_val) in enumerate(value)\\n            elem_type_str = strip(element_type_strs[idx])\\n            # Ensure element type is static for a static tuple\\n            canonical_elem_type = _get_canonical_type(elem_type_str)\\n            if canonical_elem_type == \\\"string\\\" || canonical_elem_type == \\\"bytes\\\" || endswith(canonical_elem_type, \\\"[]\\\") || (startswith(canonical_elem_type, \\\"(\\\") && occursin(r\\\"string|bytes|\\\\[\\\\]\\\", canonical_elem_type))\\n                error(\\\"Static tuple \\$canonical_type cannot contain dynamic element type '\\$elem_type_str'. This indicates an issue with how the tuple was classified as static or the ABI type string itself.\\\")\\n            end\\n            encoded_elements *= _abi_encode_static_value(elem_val, elem_type_str) # Recursive call for static elements\\n        end\\n        # Static tuples are encoded in-place and are not padded to 32 bytes themselves,\\n        # but their combined encoding contributes to the 32-byte slots of the parent structure.\\n        # If a static tuple is a top-level argument, it will be padded as part of the main encoding loop.\\n        # Here, we just return the concatenated hex of its elements.\\n        return encoded_elements\\n    else\\n        error(\\\"Unsupported static ABI type '\\$canonical_type' or value type '\\$(typeof(value))' for _abi_encode_static_value.\\\")\\n    end\\nend\\n\\nfunction create_ethereum_provider(rpc_url::String, chain_id::Int;\\n                                  default_gas_limit=300000, default_gas_price_gwei=20.0, timeout=30)\\n    \\n    config = EthereumConfig(\\n        rpc_url=rpc_url, \\n        chain_id=chain_id,\\n        default_gas_limit=default_gas_limit,\\n        default_gas_price_gwei=default_gas_price_gwei,\\n        timeout_seconds=timeout\\n    )\\n    \\n    # Attempt to connect to get network name for Blockchain.connect\\n    # This is a bit circular. Blockchain.connect should ideally just take rpc_url.\\n    # For now, we derive a placeholder network name.\\n    network_name = \\\"evm_chain_\\$(chain_id)\\\" \\n    connection = Main.Blockchain.connect(network=network_name, endpoint_url=rpc_url) # Use Main.Blockchain if Blockchain.jl is top-level\\n    \\n    if !connection[\\\"connected\\\"]\\n        error(\\\"Failed to connect to Ethereum RPC at \\$rpc_url for chain ID \\$chain_id\\\")\\n    end\\n    \\n    return EthereumProvider(config, connection)\\nend\\n\\n\\n# ===== Helper Functions =====\\n\\neth_to_wei_str(eth_amount::Number)::String = \\\"0x\\\" * string(BigInt(round(eth_amount * 10^18)), base=16)\\nwei_to_eth_float(wei_amount_hex::String)::Float64 = Float64(parse(BigInt, wei_amount_hex[3:end], base=16) / BigInt(10)^18)\\n\\n# ==============================================================================\\n# Ethereum ABI Encoding and Decoding\\n# ==============================================================================\\n#\\n# IMPORTANT LIMITATIONS:\\n# The ABI encoder/decoder implemented below has been improved to handle:\\n#   - Common static types (uintN, intN, address, bool, bytesN).\\n#   - Basic dynamic types (string, bytes, T[] where T is a static type).\\n#   - Simple static tuples/structs (e.g., a tuple where all elements are static types).\\n#\\n# However, it is NOT a fully general-purpose, ABI-compliant library.\\n# It would likely NOT correctly handle all edge cases or more complex/nested ABI structures, such as:\\n#   - Arrays of dynamic types (e.g., string[], bytes[][]).\\n#   - Tuples/structs containing dynamic types (e.g., (uint256, string, address[])).\\n#   - Deeply nested dynamic arrays or tuples.\\n#   - Complex interactions of offsets for multiple dynamic types within tuples or arrays.\\n#\\n# Achieving full ABI compliance is a substantial library development effort in itself\\n# and would ideally involve a dedicated, rigorously tested ABI library.\\n#\\n# Users should exercise CAUTION and TEST THOROUGHLY when using these functions\\n# with complex ABI structures beyond the explicitly supported cases.\\n# For production systems dealing with arbitrary or complex ABIs, consider integrating\\n# a more mature, specialized ABI handling library if available, or contributing\\n# to the enhancement of this one with comprehensive testing.\\n#\\n# ==============================================================================\\n\\nusing SHA # Ensure SHA is imported\\n\\n# --- ABI Encoding ---\\n\\n\\\"\\\"\\\"\\n    _get_canonical_type(abi_type_str::String)::String\\n\\nReturns the canonical form of an ABI type string for signature hashing.\\ne.g., \\\"uint\\\" -> \\\"uint256\\\", \\\"int\\\" -> \\\"int256\\\", \\\"byte\\\" -> \\\"bytes1\\\"\\nTuples are represented as \\\"(type1,type2,...)\\\".\\n\\\"\\\"\\\"\\nfunction _get_canonical_type(abi_type_str::String)::String\\n    # This is a simplified version. A full version handles all aliases and tuple structures.\\n    # Basic canonical types for Uniswap interactions\\n    type_map = Dict(\\n        \\\"uint\\\" => \\\"uint256\\\",\\n        \\\"int\\\" => \\\"int256\\\",\\n        \\\"byte\\\" => \\\"bytes1\\\",\\n        \\\"address\\\" => \\\"address\\\",\\n        \\\"bool\\\" => \\\"bool\\\",\\n        \\\"string\\\" => \\\"string\\\", # dynamic\\n        \\\"bytes\\\" => \\\"bytes\\\"   # dynamic\\n    )\\n    # Handle array types like address[] -> address[] (already canonical for this purpose)\\n    # and uint256[] etc.\\n    if endswith(abi_type_str, \\\"[]\\\")\\n        base_type = replace(abi_type_str, \\\"[]\\\" => \\\"\\\")\\n        return get(type_map, base_type, base_type) * \\\"[]\\\"\\n    end\\n    return get(type_map, abi_type_str, abi_type_str) # Assume already canonical if not in map\\nend\\n\\n\\n\\\"\\\"\\\"\\n    _abi_encode_static_value(value::Any, abi_type_str::String)::String\\n\\nEncodes a single static ABI type value to its 32-byte hex representation.\\n\\\"\\\"\\\"\\nfunction _abi_encode_static_value(value::Any, abi_type_str::String)::String\\n    canonical_type = _get_canonical_type(abi_type_str)\\n\\n    if canonical_type == \\\"address\\\" && isa(value, String) && startswith(value, \\\"0x\\\") && length(value) == 42\\n        return lpad(value[3:end], 64, '0')\\n    elseif (startswith(canonical_type, \\\"uint\\\") || startswith(canonical_type, \\\"int\\\")) && isa(value, Integer)\\n        bits_str = match(r\\\"(u?int)(\\\\d*)\\\", canonical_type)\\n        bits = isempty(bits_str.captures[2]) ? 256 : parse(Int, bits_str.captures[2])\\n        \\n        val_big = BigInt(value)\\n        if val_big < 0 && startswith(canonical_type, \\\"uint\\\")\\n            error(\\\"Cannot encode negative value \\$value for unsigned type \\$canonical_type\\\")\\n        end\\n        # Handle two's complement for negative signed integers\\n        if startswith(canonical_type, \\\"int\\\") && val_big < 0\\n            val_big = (BigInt(1) << bits) + val_big \\n        end\\n        hex_val = string(val_big, base=16)\\n        if length(hex_val) > div(bits, 4)\\n            error(\\\"Value \\$value too large for type \\$canonical_type (max \\$bits bits)\\\")\\n        end\\n        return lpad(hex_val, 64, '0')\\n    elseif canonical_type == \\\"bool\\\" && isa(value, Bool)\\n        return lpad(value ? \\\"1\\\" : \\\"0\\\", 64, '0')\\n    elseif startswith(canonical_type, \\\"bytes\\\") && !endswith(canonical_type, \\\"[]\\\") # bytes1..bytes32\\n        len_match = match(r\\\"bytes(\\\\d+)\\\", canonical_type)\\n        if !isnothing(len_match) && isa(value, Vector{UInt8})\\n            num_bytes = parse(Int, len_match.captures[1])\\n            if length(value) > num_bytes error(\\\"Data for bytes\\$num_bytes is too long: \\$(length(value)) bytes\\\") end\\n            return rpad(bytes2hex(value), 64, '0') # bytesN are left-aligned\\n        else\\n            error(\\\"Invalid value for bytesN type '\\$canonical_type' or value type '\\$(typeof(value))'. Expected Vector{UInt8}.\\\")\\n        end\\n    else\\n        error(\\\"Unsupported static ABI type '\\$canonical_type' or value type '\\$(typeof(value))' for _abi_encode_static_value.\\\")\\n    end\\nend\\n\\n\\\"\\\"\\\"\\n    _abi_encode_dynamic_value(value::Any, abi_type_str::String)::String\\n\\nEncodes the data part of a dynamic ABI type (e.g., string, bytes, T[]).\\nReturns the hex string of (length + data_padded_to_32_bytes).\\n\\\"\\\"\\\"\\nfunction _abi_encode_dynamic_value(value::Any, abi_type_str::String)::String\\n    canonical_type = _get_canonical_type(abi_type_str)\\n\\n    if (canonical_type == \\\"string\\\" && isa(value, String)) || (canonical_type == \\\"bytes\\\" && isa(value, Vector{UInt8}))\\n        data_bytes = isa(value, String) ? Vector{UInt8}(value) : value\\n        len_hex = lpad(string(length(data_bytes), base=16), 64, '0')\\n        data_hex = bytes2hex(data_bytes)\\n        # Pad data_hex to a multiple of 64 hex characters (32 bytes)\\n        padded_data_hex = rpad(data_hex, ceil(Int, length(data_hex) / 64) * 64, '0')\\n        return len_hex * padded_data_hex\\n    elseif endswith(canonical_type, \\\"[]\\\") && isa(value, AbstractVector) # Dynamic array of static types\\n        element_type_str = replace(canonical_type, \\\"[]\\\" => \\\"\\\")\\n        \\n        # Check if the element type is itself dynamic (e.g. string, bytes, another_array[], or a dynamic tuple)\\n        is_element_type_dynamic = false\\n        if element_type_str == \\\"string\\\" || element_type_str == \\\"bytes\\\" || endswith(element_type_str, \\\"[]\\\")\\n            is_element_type_dynamic = true\\n        elseif startswith(element_type_str, \\\"(\\\") && endswith(element_type_str, \\\")\\\") # Element is a tuple\\n            # Check if this tuple type is dynamic\\n            temp_element_types_str_content = element_type_str[2:end-1]\\n            temp_element_type_strs_tuple = []\\n            balance_tuple = 0; current_type_tuple_temp = \\\"\\\"\\n            for char_tt in temp_element_types_str_content\\n                if char_tt == '(' balance_tuple +=1 elseif char_tt == ')' balance_tuple -=1 end\\n                if char_tt == ',' && balance_tuple == 0\\n                    push!(temp_element_type_strs_tuple, strip(current_type_tuple_temp)); current_type_tuple_temp = \\\"\\\"\\n                else current_type_tuple_temp *= char_tt end\\n            end\\n            push!(temp_element_type_strs_tuple, strip(current_type_tuple_temp))\\n            for elem_type_str_check_tuple in temp_element_type_strs_tuple\\n                canonical_elem_type_check_tuple = _get_canonical_type(strip(elem_type_str_check_tuple))\\n                if canonical_elem_type_check_tuple == \\\"string\\\" || canonical_elem_type_check_tuple == \\\"bytes\\\" || endswith(canonical_elem_type_check_tuple, \\\"[]\\\") ||\\n                   (startswith(canonical_elem_type_check_tuple, \\\"(\\\") && occursin(r\\\"string|bytes|\\\\[\\\\]\\\", canonical_elem_type_check_tuple))\\n                    is_element_type_dynamic = true; break\\n                end\\n            end\\n        end\\n\\n        if is_element_type_dynamic\\n            # Array of dynamic types (e.g., string[], bytes[], MyDynamicStruct[])\\n            # This is complex: head contains offsets to each element's data in the tail.\\n            @error \\\"Encoding arrays of dynamic types (e.g., string[], bytes[][], or arrays of dynamic structs) is NOT YET FULLY SUPPORTED and may produce incorrect results. Type: \\$canonical_type\\\"\\n            # Placeholder logic: encode length, then try to encode each dynamic element's data sequentially.\\n            # This will be incorrect for offsets. A proper implementation needs to calculate all tail sizes first.\\n            len_hex = lpad(string(length(value), base=16), 64, '0')\\n            \\n            # This part needs a complete rewrite for arrays of dynamic types.\\n            # It should build a head part (offsets) and a tail part (actual data of dynamic elements).\\n            # For now, this will likely be incorrect.\\n            elements_data_hex = \\\"\\\"\\n            # This is a conceptual placeholder.\\n            # Each `elem` here is dynamic. Its encoding would be its own data block.\\n            # The main array's data part should contain *offsets* to these blocks.\\n            # current_offset_for_array_elements = length(value) * 32 # bytes, after all offset words\\n            # temp_array_head_parts = []\\n            # temp_array_tail_parts = []\\n            # for elem_dyn in value\\n            #     push!(temp_array_head_parts, lpad(string(current_offset_for_array_elements, base=16), 64, '0'))\\n            #     encoded_elem_dyn_data = _abi_encode_dynamic_value(elem_dyn, element_type_str) # This recursive call is problematic if not careful with context\\n            #     push!(temp_array_tail_parts, encoded_elem_dyn_data)\\n            #     current_offset_for_array_elements += div(length(encoded_elem_dyn_data),2) # This is length of data, not just one word\\n            # end\\n            # elements_hex = join(temp_array_head_parts) * join(temp_array_tail_parts)\\n            # The above is still not quite right for the general case of _abi_encode_dynamic_value.\\n            # This function is meant to return the *data block* for one dynamic item.\\n            # If that item is an array of dynamic things, its data block is (length, offset1, offset2, ..., data1, data2, ...).\\n\\n            # Array of dynamic types (e.g., string[], bytes[], MyDynamicStruct[])\\n            len_hex = lpad(string(length(value), base=16), 64, '0')\\n            \\n            # Head part of the array data will contain offsets to each dynamic element.\\n            # Tail part will contain the actual data of each dynamic element.\\n            array_head_parts_hex = String[] # Will store offsets\\n            array_tail_parts_hex = String[] # Will store encoded data of dynamic elements\\n            \\n            # The first offset is relative to the start of the array's data block (i.e., after len_hex).\\n            # This offset points to the start of the first dynamic element's data, which comes *after* all the offset words.\\n            # Number of offset words = number of elements in the array.\\n            current_offset_in_tail_bytes = length(value) * 32 \\n\\n            for elem_val in value\\n                push!(array_head_parts_hex, lpad(string(current_offset_in_tail_bytes, base=16), 64, '0'))\\n                \\n                # Now encode the dynamic element itself.\\n                # If element_type_str is \\\"string\\\" or \\\"bytes\\\", _abi_encode_dynamic_value handles it.\\n                # If element_type_str is a dynamic tuple like \\\"(uint,string)\\\", we need a robust way to encode it.\\n                local encoded_elem_data::String\\n                if element_type_str == \\\"string\\\" || element_type_str == \\\"bytes\\\"\\n                    # This is a direct call for simple dynamic types (string, bytes).\\n                    # It returns (length + data_padded).\\n                    encoded_elem_data = _abi_encode_dynamic_value(elem_val, element_type_str)\\n                elseif startswith(element_type_str, \\\"(\\\") && endswith(element_type_str, \\\")\\\") # Element is a dynamic tuple\\n                    # This is the complex case: (uint,string)[]\\n                    # We need a function to encode the *data* of one dynamic tuple.\\n                    # This function would itself handle internal head/tail for that tuple.\\n                    # Let's call a conceptual _abi_encode_one_dynamic_tuple_data\\n                    # For now, this is a major point of complexity not fully implemented.\\n                    @error \\\"Encoding for array element of dynamic tuple type '\\$element_type_str' is complex and likely incomplete/incorrect.\\\"\\n                    # Placeholder: try to encode its parts sequentially, which is wrong for internal dynamic parts.\\n                    # This needs a recursive call to a full tuple encoder.\\n                    # This is a placeholder and will likely be incorrect for complex dynamic tuples.\\n                    # It should call a function that returns the complete encoded block for the tuple.\\n                    # For now, let's assume a simplified (and likely incorrect for nested dynamics) encoding.\\n                    # This part needs a dedicated recursive tuple encoder.\\n                    # For the purpose of this step, we'll just error out or return a placeholder.\\n                    # error(\\\"Full encoding of arrays of dynamic tuples like '\\$canonical_type' is not yet implemented.\\\")\\n                    # Let's try a simplified concatenation, knowing it's limited:\\n                    temp_dyn_tuple_element_types_str_content = element_type_str[2:end-1]\\n                    temp_dyn_tuple_element_type_strs = []\\n                    balance_dtt = 0; current_type_dtt_temp = \\\"\\\"\\n                    for char_dtt in temp_dyn_tuple_element_types_str_content\\n                        if char_dtt == '(' balance_dtt +=1 elseif char_dtt == ')' balance_dtt -=1 end\\n                        if char_dtt == ',' && balance_dtt == 0\\n                            push!(temp_dyn_tuple_element_type_strs, strip(current_type_dtt_temp)); current_type_dtt_temp = \\\"\\\"\\n                        else current_type_dtt_temp *= char_dtt end\\n                    end\\n                    push!(temp_dyn_tuple_element_type_strs, strip(current_type_dtt_temp))\\n\\n                    # This is where _abi_encode_one_dynamic_tuple_data would be called.\\n                    # It would return the complete encoded block for this one tuple.\\n                    # For now, we'll use a simplified, likely incorrect approach for demonstration.\\n                    # This needs a proper recursive encoder for dynamic tuples.\\n                    # The output of this should be the *entire data block* for the tuple.\\n                    # For example, for (uint256, string), it would be (static_uint_val, offset_to_string_data, string_len, string_data_padded).\\n                    # This is too complex to correctly implement in this single step without a full recursive encoder.\\n                    # We will mark this as a known major limitation.\\n                    @warn \\\"Simplified encoding for elements of type '\\$element_type_str' in an array. May be incorrect for nested dynamic parts.\\\"\\n                    encoded_elem_data = \\\"\\\" # Placeholder for the dynamic tuple's data block\\n                    # This loop is a naive attempt and incorrect for dynamic tuples with internal dynamic parts.\\n                    # It should be replaced by a call to a recursive tuple encoder.\\n                    # For (uint, string), the uint is static, string is dynamic.\\n                    # The tuple's encoding would be: uint_val (32 bytes) + offset_to_string (32 bytes) + string_len (32 bytes) + string_data_padded.\\n                    # This is what _abi_encode_one_dynamic_tuple_data should produce.\\n                    # For now, we cannot correctly form `encoded_elem_data` here for dynamic tuples.\\n                    # The original error for string[] or bytes[] was more direct.\\n                    # Let's reinstate an error for arrays of dynamic tuples for now.\\n                     error(\\\"Encoding arrays of dynamic tuples (e.g. (uint,string)[]) is not yet fully supported. Type: \\$canonical_type\\\")\\n\\n                elseif endswith(element_type_str, \\\"[]\\\") # Array of arrays (e.g. uint[][])\\n                     error(\\\"Encoding multi-dimensional arrays or arrays of arrays (e.g., uint[][], string[][]) is not supported by this simplified encoder. Type: \\$canonical_type\\\")\\n                else\\n                    # Should not happen if is_element_type_dynamic was determined correctly\\n                    error(\\\"Unexpected dynamic element type in array: \\$element_type_str\\\")\\n                end\\n                \\n                push!(array_tail_parts_hex, encoded_elem_data)\\n                current_offset_in_tail_bytes += div(length(encoded_elem_data), 2) # Add length of this element's data block\\n            end\\n            return len_hex * join(array_head_parts_hex) * join(array_tail_parts_hex)\\n\\n        else # Array of static types (including static tuples)\\n            len_hex = lpad(string(length(value), base=16), 64, '0')\\n            # _abi_encode_static_value now handles static tuples correctly.\\n            elements_hex = join([_abi_encode_static_value(elem, element_type_str) for elem in value])\\n            return len_hex * elements_hex\\n        end\\n    else\\n        error(\\\"Unsupported dynamic ABI type '\\$canonical_type' or value type '\\$(typeof(value))' for _abi_encode_dynamic_value.\\\")\\n    end\\nend\\n\\n\\n\\\"\\\"\\\"\\nEncodes function arguments for an EVM contract call.\\n`function_signature_str` e.g., \\\"transfer(address,uint256)\\\" (canonical types)\\n`args_with_types` e.g., [(\\\"0x123...\\\", \\\"address\\\"), (100, \\\"uint256\\\")]\\n\\n**Current known limitations for `encode_function_call_abi`:**\\n- Does not fully support encoding of tuples/structs that themselves contain dynamic types.\\n  The offset calculation for multiple dynamic elements within a tuple is simplified and may be incorrect.\\n- Arrays of dynamic types (e.g., `string[]`) are explicitly not supported.\\n- Deeply nested structures may not be handled correctly.\\n\\\"\\\"\\\"\\nfunction encode_function_call_abi(function_signature_str::String, args_with_types::Vector{Tuple{Any, String}})::String\\n    # @warn \\\"\\\"\\\"encode_function_call_abi: This implementation is improved to handle static tuples (structs)\\n    #          and basic dynamic types, but has limitations for complex nested dynamic types (see notes above). \\n    #          Use with caution and test thoroughly for your specific ABI.\\\"\\\"\\\"\\n    \\n    sig_bytes = Vector{UInt8}(function_signature_str)\\n    hash_bytes = SHA.keccak256(sig_bytes)\\n    selector = bytes2hex(hash_bytes[1:4])\\n    \\n    head_parts_hex = String[]\\n    tail_parts_hex = String[]\\n    \\n    # Calculate initial offset for dynamic data: number of args * 32 bytes\\n    # This is the offset from the beginning of the arguments block (after selector)\\n    current_dynamic_offset_bytes = length(args_with_types) * 32 \\n\\n    # First pass: encode static parts and offsets for dynamic parts\\n    for (arg_val, arg_type_str) in args_with_types\\n        canonical_arg_type = _get_canonical_type(arg_type_str)\\n        is_dynamic = canonical_arg_type == \\\"string\\\" || canonical_arg_type == \\\"bytes\\\" || endswith(canonical_arg_type, \\\"[]\\\")\\n\\n        if is_dynamic\\n            # For dynamic types, head part is the offset to its data in the tail\\n            push!(head_parts_hex, lpad(string(current_dynamic_offset_bytes, base=16), 64, '0'))\\n            \\n            encoded_dynamic_data = _abi_encode_dynamic_value(arg_val, canonical_arg_type)\\n            push!(tail_parts_hex, encoded_dynamic_data)\\n            current_dynamic_offset_bytes += div(length(encoded_dynamic_data), 2) # Length of data part only\\n\\n        elseif startswith(canonical_arg_type, \\\"(\\\") && endswith(canonical_arg_type, \\\")\\\") # Tuple/Struct as an argument\\n            # This is where the logic for handling tuples (static or dynamic) as arguments goes.\\n            # A static tuple is encoded in place. A dynamic tuple has its offset encoded in place,\\n            # and its actual content (which itself might have head/tail parts) goes into the tail.\\n\\n            # For now, we assume _abi_encode_static_value can handle *static* tuples.\\n            # If a tuple is dynamic (contains dynamic members), it needs special handling here.\\n            # This simplified encoder might not correctly handle dynamic tuples as direct arguments yet.\\n            # The check for is_tuple_dynamic was inside the tuple handling block.\\n            # Let's refine this:\\n            \\n            # Determine if the tuple itself is dynamic\\n            is_tuple_dynamic = false # Placeholder: needs proper check\\n            temp_element_types_str_content = canonical_arg_type[2:end-1]\\n            temp_element_type_strs = []\\n            balance = 0; current_type_temp = \\\"\\\"\\n            for char_t in temp_element_types_str_content\\n                if char_t == '(' balance +=1 elseif char_t == ')' balance -=1 end\\n                if char_t == ',' && balance == 0\\n                    push!(temp_element_type_strs, strip(current_type_temp)); current_type_temp = \\\"\\\"\\n                else current_type_temp *= char_t end\\n            end\\n            push!(temp_element_type_strs, strip(current_type_temp))\\n\\n            for elem_type_str_check in temp_element_type_strs\\n                canonical_elem_type_check = _get_canonical_type(strip(elem_type_str_check))\\n                if canonical_elem_type_check == \\\"string\\\" || canonical_elem_type_check == \\\"bytes\\\" || endswith(canonical_elem_type_check, \\\"[]\\\") ||\\n                   (startswith(canonical_elem_type_check, \\\"(\\\") && occursin(r\\\"string|bytes|\\\\[\\\\]\\\", canonical_elem_type_check)) # Heuristic for nested dynamic tuple\\n                    is_tuple_dynamic = true\\n                    break\\n                end\\n            end\\n\\n            if is_tuple_dynamic\\n                # Dynamic tuple: encode offset in head, actual tuple data in tail.\\n                # This is the complex case requiring recursive encoding with offset management.\\n                @error \\\"Encoding of dynamic tuples/structs as direct function arguments is NOT YET FULLY SUPPORTED and may be incorrect. Arg type: \\$canonical_arg_type\\\"\\n                # Placeholder: push offset, and a (likely incorrect) concatenation for tail.\\n                push!(head_parts_hex, lpad(string(current_dynamic_offset_bytes, base=16), 64, '0'))\\n                \\n                # This is where a recursive call to a full tuple encoder would go.\\n                # For now, it will likely fail or produce wrong results for complex dynamic tuples.\\n                # Let's try to use _abi_encode_static_value which now handles static tuples,\\n                # but it will error if it finds dynamic elements inside what it expects to be a static tuple.\\n                # This highlights the need for a proper _abi_encode_tuple_value that handles internal dynamics.\\n                # For now, this path for dynamic tuples as arguments is problematic.\\n                # We'll let it attempt with _abi_encode_static_value, which will error if it's truly dynamic.\\n                # A better approach would be a dedicated _abi_encode_tuple_data function.\\n                \\n                # --- Placeholder for dynamic tuple encoding ---\\n                # This part needs a robust recursive encoder.\\n                # The current _abi_encode_static_value is for *static* tuples.\\n                # If we pass a dynamic tuple type string to it, it will error.\\n                # For now, we'll just try to encode it as if it were static, which is wrong\\n                # if it has dynamic members, but illustrates the point of needing a proper handler.\\n                # A truly dynamic tuple's encoding would itself have a head (for its static parts and offsets)\\n                # and a tail (for its dynamic parts' data).\\n                \\n                # This is a conceptual placeholder for what `_abi_encode_dynamic_tuple_data` would do:\\n                # encoded_dynamic_tuple_data_block = _abi_encode_tuple_recursively(arg_val, element_type_strs)\\n                # push!(tail_parts_hex, encoded_dynamic_tuple_data_block)\\n                # current_dynamic_offset_bytes += div(length(encoded_dynamic_tuple_data_block), 2)\\n                # For now, we'll let it fall through to the static type encoding, which will error if the tuple is dynamic.\\n                # This is not ideal but reflects the current limitation.\\n                # A proper solution requires a recursive tuple encoder.\\n                # Let's assume for now that if a tuple is passed as a direct argument and is_tuple_dynamic is true,\\n                # it's an unsupported complex case for this simplified encoder.\\n                # The error in _abi_encode_static_value for dynamic elements in a tuple will catch this.\\n                # So, we treat it like a static type for the head part, which means it's encoded in-place.\\n                # This is only correct if the tuple is actually static.\\n                # If is_tuple_dynamic is true, this path is problematic.\\n                # The logic for `is_tuple_dynamic` needs to correctly decide if it's placed in head or tail.\\n                # If dynamic, it's an offset in head, data in tail.\\n                # If static, it's data in head.\\n                # The current `_abi_encode_static_value` handles static tuples.\\n                # So, if `is_tuple_dynamic` is true, we need to place an offset.\\n                \\n                # Corrected logic:\\n                if is_tuple_dynamic\\n                    push!(head_parts_hex, lpad(string(current_dynamic_offset_bytes, base=16), 64, '0'))\\n                    # This is where a call to a proper recursive tuple encoder for the tail would go.\\n                    # e.g., encoded_tuple_data = _encode_tuple_data_recursively(arg_val, element_type_strs, initial_offset_within_tuple_data_block)\\n                    # For now, this remains a significant limitation.\\n                    # We'll push a placeholder or error if we try to fully implement this here.\\n                    # Let's assume for now that if a tuple is dynamic, we cannot properly encode its tail part yet.\\n                    # The `_abi_encode_dynamic_value` should be the one to handle this if the tuple is part of an array.\\n                    # If it's a direct argument, this `encode_function_call_abi` needs to manage its tail.\\n                    @error \\\"Full encoding of dynamic tuples as direct arguments is complex and not fully implemented. Arg type: \\$canonical_arg_type. Result may be incorrect.\\\"\\n                    # Fallback: attempt to encode its elements as if it were a sequence of static items for the tail, which is wrong.\\n                    temp_tail_data = \\\"\\\"\\n                    for (idx_tt, elem_val_tt) in enumerate(arg_val)\\n                        temp_tail_data *= _abi_encode_static_value(elem_val_tt, strip(temp_element_type_strs[idx_tt]))\\n                    end\\n                    push!(tail_parts_hex, temp_tail_data) # This is likely incorrect for dynamic tuples\\n                    current_dynamic_offset_bytes += div(length(temp_tail_data), 2)\\n                else # Tuple is static\\n                    push!(head_parts_hex, _abi_encode_static_value(arg_val, canonical_arg_type))\\n                end\\n\\n            end\\n        else # Simple static type\\n            push!(head_parts_hex, _abi_encode_static_value(arg_val, canonical_arg_type))\\n        end\\n    end\\n    \\n    return \\\"0x\\\" * selector * join(head_parts_hex) * join(tail_parts_hex)\\nend\\n\\n# --- ABI Decoding (Conceptual Placeholders) ---\\n\\n\\\"\\\"\\\"\\nDecodes a single 32-byte data segment from hex based on a canonical ABI type string.\\n\\\"\\\"\\\"\\nfunction _abi_decode_value(data_segment_hex::String, abi_type_str::String, full_data_hex_no_prefix::String, current_data_ptr::Ref{Int})::Any\\n    canonical_type = _get_canonical_type(abi_type_str)\\n\\n    if canonical_type == \\\"address\\\"\\n        return \\\"0x\\\" * data_segment_hex[end-39:end] # Address is last 20 bytes of the 32-byte word\\n    elseif startswith(canonical_type, \\\"uint\\\") || startswith(canonical_type, \\\"int\\\")\\n        # For uintN and intN, they are right-padded in the 32-byte word.\\n        # The parse function handles the full 32-byte hex.\\n        val = parse(BigInt, data_segment_hex, base=16)\\n        bits_match = match(r\\\"(u?int)(\\\\d*)\\\", canonical_type)\\n        bits = if !isnothing(bits_match) && !isempty(bits_match.captures[2])\\n                    parse(Int, bits_match.captures[2])\\n                 elseif canonical_type == \\\"uint\\\" || canonical_type == \\\"int\\\" # Default to 256 if no size specified\\n                    256\\n                 else # Fallback for types like uint112, uint160, int24\\n                    # Try to extract from type string directly if not matching common pattern\\n                    num_str = filter(isdigit, canonical_type)\\n                    isempty(num_str) ? 256 : parse(Int, num_str) # Default to 256 if no digits found\\n                 end\\n\\n        if startswith(canonical_type, \\\"int\\\") && val >= (BigInt(1) << (bits - 1)) # Check sign bit\\n            val -= (BigInt(1) << bits) # Convert from two's complement\\n        end\\n        return val\\n    elseif canonical_type == \\\"bool\\\"\\n        return parse(BigInt, data_segment_hex, base=16) != 0\\n    elseif startswith(canonical_type, \\\"bytes\\\") && !endswith(canonical_type, \\\"[]\\\") # bytes1..bytes32\\n        len_match = match(r\\\"bytes(\\\\d+)\\\", canonical_type)\\n        if !isnothing(len_match)\\n            num_bytes = parse(Int, len_match.captures[1])\\n            # bytesN are left-padded (stored at the beginning of the 32-byte word)\\n            return hex2bytes(data_segment_hex[1 : num_bytes*2]) \\n        end\\n    # --- Dynamic Type Decoding ---\\n    elseif canonical_type == \\\"string\\\" || canonical_type == \\\"bytes\\\"\\n        # data_segment_hex contains the offset to the dynamic data part.\\n        offset_bytes = parse(Int, data_segment_hex, base=16)\\n        # Offset is in bytes from the start of the *entire data block* (data_hex_no_prefix).\\n        # Convert byte offset to character index (1-based for Julia strings).\\n        offset_char_idx = offset_bytes * 2 + 1\\n\\n        if offset_char_idx + 64 - 1 > length(full_data_hex_no_prefix)\\n            @error \\\"ABI Decoding: Offset for dynamic type \\$canonical_type points out of bounds or not enough data for length.\\\"\\n            return \\\"ERROR_DECODING_OFFSET_\\$(canonical_type)\\\"\\n        end\\n        \\n        # Read the length of the data (which is itself a uint256)\\n        len_hex = full_data_hex_no_prefix[offset_char_idx : offset_char_idx + 63]\\n        len_bytes = parse(Int, len_hex, base=16)\\n        \\n        data_start_char_idx = offset_char_idx + 64\\n        data_hex_chars_to_read = len_bytes * 2\\n\\n        if data_start_char_idx + data_hex_chars_to_read - 1 > length(full_data_hex_no_prefix)\\n            @error \\\"ABI Decoding: Dynamic type \\$canonical_type data length (\\$len_bytes bytes) exceeds available data.\\\"\\n            return \\\"ERROR_DECODING_DATA_LENGTH_\\$(canonical_type)\\\"\\n        end\\n        \\n        actual_data_hex = full_data_hex_no_prefix[data_start_char_idx : data_start_char_idx + data_hex_chars_to_read - 1]\\n        \\n        return canonical_type == \\\"string\\\" ? String(hex2bytes(actual_data_hex)) : hex2bytes(actual_data_hex)\\n\\n    elseif endswith(canonical_type, \\\"[]\\\") # Dynamic array of static types\\n        offset_bytes = parse(Int, data_segment_hex, base=16)\\n        offset_char_idx = offset_bytes * 2 + 1\\n\\n        if offset_char_idx + 64 - 1 > length(full_data_hex_no_prefix)\\n            @error \\\"ABI Decoding: Offset for dynamic array \\$canonical_type points out of bounds.\\\"\\n            return [\\\"ERROR_DECODING_ARRAY_OFFSET\\\"]\\n        end\\n\\n        len_elements = parse(Int, full_data_hex_no_prefix[offset_char_idx : offset_char_idx + 63], base=16)\\n        elements_data_start_char_idx = offset_char_idx + 64\\n        \\n        element_type_str = replace(canonical_type, \\\"[]\\\" => \\\"\\\")\\n        if element_type_str == \\\"string\\\" || element_type_str == \\\"bytes\\\" || endswith(element_type_str, \\\"[]\\\")\\n            @error \\\"Decoding arrays of dynamic types (e.g., string[], bytes[][]) is not supported by this simplified decoder.\\\"\\n            return [\\\"ERROR_ARRAY_OF_DYNAMIC_UNSUPPORTED\\\"]\\n        end\\n\\n        decoded_array_elements = Any[]\\n        current_element_char_idx = elements_data_start_char_idx\\n        for _ in 1:len_elements\\n            if current_element_char_idx + 64 -1 > length(full_data_hex_no_prefix)\\n                @error \\\"ABI Decoding: Not enough data for all elements of dynamic array \\$canonical_type.\\\"\\n                break\\n            end\\n            element_segment_hex = full_data_hex_no_prefix[current_element_char_idx : current_element_char_idx + 63]\\n            # For static elements in a dynamic array, current_data_ptr is not used by _abi_decode_value for the element itself.\\n            # The full_data_hex_no_prefix is passed in case an element *was* dynamic (though we error out above for that).\\n            push!(decoded_array_elements, _abi_decode_value(element_segment_hex, element_type_str, full_data_hex_no_prefix, current_data_ptr)) # current_data_ptr is not strictly needed here for static elements\\n            current_element_char_idx += 64\\n        end\\n        return decoded_array_elements\\n    end\\n    @warn \\\"Unsupported ABI type '\\$abi_type_str' for decoding. Returning raw hex segment.\\\"\\n    return \\\"0x\\\" * data_segment_hex\\nend\\n\\n\\\"\\\"\\\"\\nDecodes function call result data.\\n`output_abi_types` is a vector of canonical ABI type strings like [\\\"address\\\", \\\"uint256\\\"].\\n\\n**Current known limitations for `decode_function_result_abi`:**\\n- Does not support decoding of arrays of dynamic types (e.g., `string[]`).\\n- Decoding of tuples/structs containing dynamic types is not implemented/tested.\\n- Assumes a flat structure for output types; nested tuples in output are not explicitly handled.\\n\\\"\\\"\\\"\\nfunction decode_function_result_abi(result_hex::String, output_abi_types::Vector{String})::Vector{Any}\\n    # @warn \\\"\\\"\\\"decode_function_result_abi: This implementation is improved for static types and basic dynamic types/arrays.\\n    #          However, it has limitations for complex nested or dynamic structures (see notes above).\\n    #          Use with caution and test thoroughly for your specific ABI.\\\"\\\"\\\"\\n    \\n    (isempty(result_hex) || result_hex == \\\"0x\\\" || length(result_hex) < 2) && return Any[] # Allow \\\"0x\\\" for empty returns\\n    if result_hex == \\\"0x\\\" && !isempty(output_abi_types)\\n        @warn \\\"ABI decoding: Received '0x' but expected outputs \\$(output_abi_types). Returning empty array.\\\"\\n        return Any[]\\n    elseif result_hex == \\\"0x\\\" && isempty(output_abi_types)\\n        return Any[] # Valid empty return\\n    end\\n\\n    data_hex_no_prefix = result_hex[3:end]\\n    if isempty(data_hex_no_prefix) && !isempty(output_abi_types)\\n         @warn \\\"ABI decoding: Received empty data string (after 0x) but expected outputs \\$(output_abi_types). Returning empty.\\\"\\n        return Any[]\\n    elseif isempty(data_hex_no_prefix) && isempty(output_abi_types)\\n        return Any[] # Valid empty return\\n    end\\n\\n\\n    outputs = Any[]\\n    head_read_char_idx = 1 # Character index in data_hex_no_prefix for reading head slots\\n    \\n    # The start of the dynamic data section is after all head slots.\\n    # Each head slot is 32 bytes (64 hex chars).\\n    dynamic_section_start_char_idx = (length(output_abi_types) * 64) + 1\\n    current_dynamic_read_ptr = Ref(dynamic_section_start_char_idx) # Ref to pass for modification\\n\\n    for type_str in output_abi_types\\n        # Ensure there's enough data for a 32-byte head slot\\n        if head_read_char_idx + 64 - 1 > length(data_hex_no_prefix)\\n            @error \\\"ABI decoding: Not enough data left in head to decode type '\\$type_str'. Expected 32 bytes, got \\$(length(data_hex_no_prefix) - head_read_char_idx + 1) chars. Decoded \\$(length(outputs)).\\\"\\n            # This often indicates an issue with the contract call or the expected output_abi_types.\\n            break \\n        end\\n        segment_hex = data_hex_no_prefix[head_read_char_idx : head_read_char_idx + 63]\\n        \\n        # The _abi_decode_value function will handle if it's static or needs to look at dynamic part.\\n        # It will use/update current_dynamic_read_ptr if it decodes a dynamic type from its offset.\\n        # Note: The current _abi_decode_value for dynamic types is still a placeholder.\\n        decoded_val = _abi_decode_value(segment_hex, type_str, data_hex_no_prefix, current_dynamic_read_ptr)\\n        push!(outputs, decoded_val)\\n        \\n        head_read_char_idx += 64 # Move to the next 32-byte slot in the head\\n    end\\n    return outputs\\nend\\n\\n\\n# ===== Ethereum RPC Method Wrappers =====\\n# These use the _make_generic_rpc_request from the parent Blockchain module.\\n\\nfunction call_contract_evm(provider::EthereumProvider, contract_address::String, data::String; block::String=\\\"latest\\\")::String\\n    if !provider.connection_dict[\\\"connected\\\"] error(\\\"Provider not connected.\\\") end\\n    params = [Dict(\\\"to\\\" => contract_address, \\\"data\\\" => data), block]\\n    # Assumes _make_generic_rpc_request is available from parent Blockchain module\\n    return Main.Blockchain._make_generic_rpc_request(provider.config.rpc_url, \\\"eth_call\\\", params)\\nend\\n\\nfunction get_nonce_evm(provider::EthereumProvider, address::String; block::String=\\\"latest\\\")::Int\\n    if !provider.connection_dict[\\\"connected\\\"] error(\\\"Provider not connected.\\\") end\\n    hex_nonce = Main.Blockchain._make_generic_rpc_request(provider.config.rpc_url, \\\"eth_getTransactionCount\\\", [address, block])\\n    return parse(Int, hex_nonce[3:end], base=16)\\nend\\n\\nfunction estimate_gas_evm(provider::EthereumProvider, tx_params::Dict)::Int\\n    # tx_params should include: from, to, value (optional), data (optional)\\n    if !provider.connection_dict[\\\"connected\\\"] error(\\\"Provider not connected.\\\") end\\n    hex_gas = Main.Blockchain._make_generic_rpc_request(provider.config.rpc_url, \\\"eth_estimateGas\\\", [tx_params])\\n    return parse(Int, hex_gas[3:end], base=16)\\nend\\n\\n# get_balance_evm, send_transaction_evm, etc., would also be implemented here,\\n# potentially calling _make_generic_rpc_request or more specific logic.\\n# They might also use functions from Blockchain.jl if those are sufficiently generic\\n# and just need the connection dictionary.\\n\\n# Example:\\nfunction get_balance_evm(provider::EthereumProvider, address::String; block::String=\\\"latest\\\")::Float64\\n    if !provider.connection_dict[\\\"connected\\\"] error(\\\"Provider not connected.\\\") end\\n    # This can directly use the generic function if it's suitable\\n    return Main.Blockchain.get_balance_generic(address, provider.connection_dict)\\nend\\n\\n# Note: Functions like send_transaction_evm would involve signing, which is complex\\n# and requires secure private key management, not handled in this illustrative client.\\n\\n@info \\\"EthereumClient.jl loaded.\\\"\\n\\nend # module EthereumClient\\n\", 0, \"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\EthereumClient.jl\", 1, [1, 5, 64, 65, 139, 210, 250, 254, 276, 277, 327, 414, 491, 580, 674, 675, 741, 859, 898, 984, 1046, 1047, 1051, 1070, 1071, 1113, 1192, 1265, 1269, 1291, 1311, 1329, 1433, 1460, 1506, 1531, 1536, 1566, 1591, 1648, 1690, 1745, 1779, 1785, 1876, 1884, 1888, 1889, 1893, 1914, 1915, 1975, 2050, 2054, 2078, 2147, 2233, 2234, 2323, 2364, 2448, 2460, 2560, 2617, 2679, 2737, 2852, 2929, 2942, 3069, 3081, 3179, 3240, 3363, 3375, 3435, 3466, 3505, 3551, 3625, 3668, 3749, 3791, 3803, 3857, 3858, 3912, 4076, 4088, 4089, 4119, 4167, 4225, 4288, 4357, 4574, 4781, 4797, 4916, 4928, 5016, 5112, 5218, 5287, 5319, 5328, 5454, 5462, 5466, 5467, 5533, 5634, 5639, 5668, 5694, 5721, 5766, 5821, 5853, 5859, 5864, 5932, 6015, 6068, 6112, 6249, 6254, 6286, 6372, 6380, 6385, 6433, 6437, 6438, 6439, 6470, 6471, 6574, 6697, 6698, 6779, 6816, 6897, 6899, 6924, 6997, 7061, 7134, 7222, 7224, 7293, 7395, 7454, 7538, 7584, 7674, 7676, 7762, 7834, 7836, 7915, 7984, 8070, 8150, 8211, 8213, 8294, 8295, 8330, 8331, 8354, 8355, 8359, 8413, 8414, 8486, 8551, 8598, 8602, 8661, 8754, 8807, 8828, 8857, 8884, 8912, 8944, 8970, 9010, 9049, 9055, 9145, 9170, 9206, 9260, 9318, 9326, 9420, 9424, 9425, 9426, 9430, 9501, 9502, 9576, 9580, 9656, 9711, 9712, 9819, 9862, 9970, 10028, 10114, 10123, 10155, 10216, 10307, 10319, 10382, 10442, 10495, 10507, 10550, 10592, 10678, 10690, 10728, 10784, 10832, 10932, 10989, 11051, 11109, 11224, 11301, 11314, 11441, 11453, 11462, 11588, 11596, 11600, 11601, 11605, 11677, 11678, 11750, 11812, 11816, 11893, 11948, 11949, 12067, 12138, 12207, 12248, 12317, 12402, 12443, 12547, 12610, 12619, 12731, 12771, 12878, 12921, 13026, 13076, 13147, 13193, 13253, 13311, 13407, 13463, 13581, 13641, 13657, 13737, 13811, 13915, 14078, 14215, 14273, 14293, 14309, 14321, 14322, 14357, 14439, 14528, 14724, 14833, 14948, 15016, 15029, 15107, 15210, 15264, 15299, 15347, 15432, 15515, 15616, 15657, 15698, 15734, 15848, 16009, 16079, 16215, 16233, 16320, 16420, 16506, 16634, 16635, 16717, 16785, 16798, 16886, 16964, 17029, 17119, 17132, 17237, 17362, 17434, 17497, 17498, 17532, 17638, 17655, 17712, 17812, 17926, 17974, 18053, 18139, 18196, 18290, 18411, 18475, 18559, 18650, 18731, 18821, 18963, 19079, 19154, 19255, 19358, 19468, 19543, 19641, 19761, 19843, 19932, 19990, 20054, 20131, 20233, 20296, 20422, 20489, 20513, 20603, 20604, 20692, 20777, 20877, 20957, 21047, 21191, 21310, 21379, 21524, 21616, 21729, 21813, 21894, 22043, 22129, 22230, 22312, 22397, 22534, 22535, 22625, 22805, 22826, 22918, 23007, 23027, 23044, 23107, 23231, 23247, 23332, 23333, 23396, 23464, 23540, 23642, 23684, 23696, 23705, 23833, 23841, 23845, 23846, 23847, 23851, 23904, 23981, 24049, 24050, 24112, 24203, 24309, 24384, 24441, 24445, 24564, 24671, 24784, 24862, 24867, 24921, 24963, 25005, 25010, 25040, 25070, 25075, 25150, 25234, 25299, 25300, 25368, 25419, 25482, 25605, 25606, 25628, 25709, 25805, 25818, 25908, 25964, 26072, 26073, 26191, 26288, 26387, 26486, 26487, 26573, 26669, 26774, 26856, 26889, 26902, 26957, 27028, 27101, 27141, 27189, 27246, 27328, 27377, 27477, 27530, 27546, 27614, 27615, 27677, 27769, 27914, 28076, 28120, 28146, 28166, 28182, 28183, 28215, 28298, 28394, 28562, 28655, 28755, 28772, 28855, 28955, 29048, 29158, 29270, 29355, 29465, 29555, 29572, 29637, 29699, 29778, 29857, 29949, 30049, 30160, 30220, 30237, 30340, 30451, 30525, 30624, 30748, 30821, 30893, 31009, 31089, 31194, 31301, 31373, 31446, 31555, 31623, 31671, 31751, 31832, 31849, 31884, 31920, 32024, 32126, 32274, 32344, 32440, 32556, 32677, 32784, 32959, 33093, 33133, 33201, 33320, 33344, 33448, 33531, 33570, 33667, 33687, 33688, 33704, 33738, 33827, 33839, 33847, 33852, 33925, 33929, 33930, 33979, 33980, 33984, 34069, 34073, 34214, 34269, 34270, 34305, 34403, 34486, 34559, 34618, 34673, 34733, 34810, 34865, 34979, 35003, 35075, 35169, 35231, 35332, 35353, 35354, 35452, 35523, 35535, 35554, 35590, 35651, 35751, 35808, 35841, 35899, 35982, 36047, 36059, 36095, 36162, 36235, 36296, 36389, 36467, 36514, 36515, 36585, 36712, 36773, 36785, 36794, 36860, 36942, 36991, 37000, 37051, 37098, 37099, 37193, 37312, 37378, 37390, 37399, 37521, 37530, 37638, 37639, 37713, 37774, 37821, 37822, 37892, 37990, 38041, 38053, 38054, 38162, 38222, 38231, 38294, 38401, 38528, 38586, 38598, 38599, 38638, 38702, 38734, 38816, 38922, 38944, 38960, 39076, 39204, 39327, 39537, 39580, 39592, 39630, 39638, 39728, 39763, 39767, 39768, 39772, 39807, 39897, 39898, 39962, 40037, 40118, 40215, 40219, 40322, 40446, 40549, 40627, 40632, 40753, 40809, 40918, 40939, 40998, 41040, 41048, 41049, 41092, 41157, 41285, 41306, 41374, 41416, 41424, 41425, 41426, 41446, 41536, 41541, 41610, 41659, 41732, 41830, 41831, 41868, 41929, 41997, 42202, 42303, 42322, 42334, 42421, 42430, 42532, 42632, 42720, 42829, 42865, 42874, 42951, 42959, 42978, 42982, 42983, 42984, 43027, 43104, 43105, 43232, 43315, 43384, 43467, 43565, 43569, 43570, 43667, 43750, 43878, 43927, 43931, 43932, 44008, 44084, 44167, 44280, 44327, 44331, 44332, 44411, 44483, 44568, 44611, 44612, 44623, 44726, 44809, 44875, 44957, 44961, 44962, 45046, 45133, 45134, 45168, 45169, 45197]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(2464, 2463, :error, \"Expected `end`\"), Base.JuliaSyntax.Diagnostic(2464, 2463, :error, \"Expected `end`\"), Base.JuliaSyntax.Diagnostic(2464, 2463, :error, \"Expected `end`\"), Base.JuliaSyntax.Diagnostic(2464, 2540, :error, \"extra tokens after end of expression\"), Base.JuliaSyntax.Diagnostic(3085, 3090, :error, \"invalid identifier\"), Base.JuliaSyntax.Diagnostic(3091, 3155, :error, \"extra tokens after end of expression\"), Base.JuliaSyntax.Diagnostic(5323, 5326, :error, \"invalid identifier\"), Base.JuliaSyntax.Diagnostic(5458, 5460, :error, \"invalid identifier\"), Base.JuliaSyntax.Diagnostic(5462, 5464, :error, \"invalid identifier\"), Base.JuliaSyntax.Diagnostic(45169, 45171, :error, \"invalid identifier\")], :none)))))","ok":false,"file":"test_address_validation.jl","seconds":2.234999895095825},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\blockchain\\\\test_solana_rpc.jl\", 68, Some tests did not pass: 13 passed, 4 failed, 6 errored, 0 broken.)","ok":false,"file":"test_solana_rpc.jl","seconds":16.090999841690063},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\blockchain\\\\test_transaction_parser.jl\", 20, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\Blockchain.jl\", 1, LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\EthereumClient.jl\", 62, Base.Meta.ParseError(\"ParseError:\\n# Error @ C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\EthereumClient.jl:62:5\\n        end\\n    elseif startswith(canonical_type, \\\"bytes\\\") && !endswith(canonical_type, \\\"[]\\\") # bytes1..bytes32\\n#   └ ── Expected `end`\", Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(\"\\\"\\\"\\\"\\nEthereumClient.jl - Ethereum blockchain client for JuliaOS\\n\\nThis module provides specific functionality for interacting with Ethereum\\nand other EVM-compatible blockchains. It builds upon generic RPC calls\\nand provides higher-level abstractions.\\n\\\"\\\"\\\"\\nmodule EthereumClient\\n\\nusing HTTP, JSON3, Dates, Base64, Printf, Logging\\n# Assuming Blockchain.jl (which might contain _make_generic_rpc_request) is accessible\\n# This might need adjustment based on how modules are structured and loaded.\\n# If Blockchain.jl `include`s this file, then _make_generic_rpc_request is in its scope.\\n# If this is a standalone submodule, it might need to import from a parent Blockchain module.\\n\\nexport EthereumConfig, EthereumProvider, create_ethereum_provider\\nexport call_contract_evm, send_transaction_evm, get_balance_evm, get_block_by_number_evm, get_transaction_by_hash_evm\\nexport get_nonce_evm, estimate_gas_evm\\nexport encode_function_call_abi, decode_function_result_abi # More ABI-aware versions\\nexport eth_to_wei_str, wei_to_eth_float # Renamed for clarity\\n\\n\\\"\\\"\\\"\\n    EthereumConfig\\n\\nConfiguration for an Ethereum/EVM client.\\n(This might be duplicative if Blockchain.jl's connection Dict holds this info.\\n Consider if this struct is needed or if connection Dict is sufficient.)\\n\\\"\\\"\\\"\\nstruct EthereumConfig\\n    rpc_url::String\\n    chain_id::Int\\n    # private_key::String # Private keys should be handled by a secure wallet/signer service, not here.\\n    default_gas_limit::Int\\n    default_gas_price_gwei::Float64 # In Gwei\\n    timeout_seconds::Int\\n    \\n    function EthereumConfig(;\\n        rpc_url::String,\\n        chain_id::Int = 1, # Default to Ethereum Mainnet\\n        default_gas_limit::Int = 300_000,\\n        default_gas_price_gwei::Float64 = 20.0, # Gwei\\n        timeout_seconds::Int = 30\\n    )\\n        new(rpc_url, chain_id, default_gas_limit, default_gas_price_gwei, timeout_seconds)\\n    end\\nend\\n\\n\\\"\\\"\\\"\\n    EthereumProvider\\n\\nRepresents a connection and configuration for an EVM chain.\\nThe `connection_dict` is the structure returned by `Blockchain.connect()`.\\n\\\"\\\"\\\"\\nstruct EthereumProvider\\n    config::EthereumConfig # Contains defaults like gas price, limit\\n    connection_dict::Dict{String, Any} # Contains rpc_url, chain_id, connected status\\n\\n    function EthereumProvider(config::EthereumConfig, connection_dict::Dict{String,Any})\\n        if !connection_dict[\\\"connected\\\"]\\n            error(\\\"Cannot create EthereumProvider with a disconnected connection.\\\")\\n        end\\n    elseif startswith(canonical_type, \\\"bytes\\\") && !endswith(canonical_type, \\\"[]\\\") # bytes1..bytes32\\n        len_match = match(r\\\"bytes(\\\\d+)\\\", canonical_type)\\n        if !isnothing(len_match) && isa(value, Vector{UInt8})\\n            num_bytes = parse(Int, len_match.captures[1])\\n            if length(value) > num_bytes error(\\\"Data for bytes\\$num_bytes is too long: \\$(length(value)) bytes\\\") end\\n            return rpad(bytes2hex(value), 64, '0') # bytesN are left-aligned\\n        else\\n            error(\\\"Invalid value for bytesN type '\\$canonical_type' or value type '\\$(typeof(value))'. Expected Vector{UInt8}.\\\")\\n        end\\n    elseif startswith(canonical_type, \\\"(\\\") && endswith(canonical_type, \\\")\\\") # Static Tuple/Struct\\n        if !isa(value, Tuple) && !isa(value, AbstractVector)\\n            error(\\\"Argument for static tuple/struct type \\$canonical_type must be a Tuple or Vector. Got \\$(typeof(value))\\\")\\n        end\\n        element_types_str_content = canonical_type[2:end-1]\\n        element_type_strs = []\\n        balance = 0; current_type = \\\"\\\"\\n        for char in element_types_str_content\\n            if char == '(' balance +=1 elseif char == ')' balance -=1 end\\n            if char == ',' && balance == 0\\n                push!(element_type_strs, strip(current_type)); current_type = \\\"\\\"\\n            else current_type *= char end\\n        end\\n        push!(element_type_strs, strip(current_type))\\n\\n        if length(value) != length(element_type_strs)\\n            error(\\\"Number of values in static tuple/struct (\\$(length(value))) does not match types in signature (\\$canonical_type -> \\$(length(element_type_strs)))\\\")\\n        end\\n\\n        encoded_elements = \\\"\\\"\\n        for (idx, elem_val) in enumerate(value)\\n            elem_type_str = strip(element_type_strs[idx])\\n            # Ensure element type is static for a static tuple\\n            canonical_elem_type = _get_canonical_type(elem_type_str)\\n            if canonical_elem_type == \\\"string\\\" || canonical_elem_type == \\\"bytes\\\" || endswith(canonical_elem_type, \\\"[]\\\") || (startswith(canonical_elem_type, \\\"(\\\") && occursin(r\\\"string|bytes|\\\\[\\\\]\\\", canonical_elem_type))\\n                error(\\\"Static tuple \\$canonical_type cannot contain dynamic element type '\\$elem_type_str'. This indicates an issue with how the tuple was classified as static or the ABI type string itself.\\\")\\n            end\\n            encoded_elements *= _abi_encode_static_value(elem_val, elem_type_str) # Recursive call for static elements\\n        end\\n        # Static tuples are encoded in-place and are not padded to 32 bytes themselves,\\n        # but their combined encoding contributes to the 32-byte slots of the parent structure.\\n        # If a static tuple is a top-level argument, it will be padded as part of the main encoding loop.\\n        # Here, we just return the concatenated hex of its elements.\\n        return encoded_elements\\n    else\\n        error(\\\"Unsupported static ABI type '\\$canonical_type' or value type '\\$(typeof(value))' for _abi_encode_static_value.\\\")\\n    end\\nend\\n\\nfunction create_ethereum_provider(rpc_url::String, chain_id::Int;\\n                                  default_gas_limit=300000, default_gas_price_gwei=20.0, timeout=30)\\n    \\n    config = EthereumConfig(\\n        rpc_url=rpc_url, \\n        chain_id=chain_id,\\n        default_gas_limit=default_gas_limit,\\n        default_gas_price_gwei=default_gas_price_gwei,\\n        timeout_seconds=timeout\\n    )\\n    \\n    # Attempt to connect to get network name for Blockchain.connect\\n    # This is a bit circular. Blockchain.connect should ideally just take rpc_url.\\n    # For now, we derive a placeholder network name.\\n    network_name = \\\"evm_chain_\\$(chain_id)\\\" \\n    connection = Main.Blockchain.connect(network=network_name, endpoint_url=rpc_url) # Use Main.Blockchain if Blockchain.jl is top-level\\n    \\n    if !connection[\\\"connected\\\"]\\n        error(\\\"Failed to connect to Ethereum RPC at \\$rpc_url for chain ID \\$chain_id\\\")\\n    end\\n    \\n    return EthereumProvider(config, connection)\\nend\\n\\n\\n# ===== Helper Functions =====\\n\\neth_to_wei_str(eth_amount::Number)::String = \\\"0x\\\" * string(BigInt(round(eth_amount * 10^18)), base=16)\\nwei_to_eth_float(wei_amount_hex::String)::Float64 = Float64(parse(BigInt, wei_amount_hex[3:end], base=16) / BigInt(10)^18)\\n\\n# ==============================================================================\\n# Ethereum ABI Encoding and Decoding\\n# ==============================================================================\\n#\\n# IMPORTANT LIMITATIONS:\\n# The ABI encoder/decoder implemented below has been improved to handle:\\n#   - Common static types (uintN, intN, address, bool, bytesN).\\n#   - Basic dynamic types (string, bytes, T[] where T is a static type).\\n#   - Simple static tuples/structs (e.g., a tuple where all elements are static types).\\n#\\n# However, it is NOT a fully general-purpose, ABI-compliant library.\\n# It would likely NOT correctly handle all edge cases or more complex/nested ABI structures, such as:\\n#   - Arrays of dynamic types (e.g., string[], bytes[][]).\\n#   - Tuples/structs containing dynamic types (e.g., (uint256, string, address[])).\\n#   - Deeply nested dynamic arrays or tuples.\\n#   - Complex interactions of offsets for multiple dynamic types within tuples or arrays.\\n#\\n# Achieving full ABI compliance is a substantial library development effort in itself\\n# and would ideally involve a dedicated, rigorously tested ABI library.\\n#\\n# Users should exercise CAUTION and TEST THOROUGHLY when using these functions\\n# with complex ABI structures beyond the explicitly supported cases.\\n# For production systems dealing with arbitrary or complex ABIs, consider integrating\\n# a more mature, specialized ABI handling library if available, or contributing\\n# to the enhancement of this one with comprehensive testing.\\n#\\n# ==============================================================================\\n\\nusing SHA # Ensure SHA is imported\\n\\n# --- ABI Encoding ---\\n\\n\\\"\\\"\\\"\\n    _get_canonical_type(abi_type_str::String)::String\\n\\nReturns the canonical form of an ABI type string for signature hashing.\\ne.g., \\\"uint\\\" -> \\\"uint256\\\", \\\"int\\\" -> \\\"int256\\\", \\\"byte\\\" -> \\\"bytes1\\\"\\nTuples are represented as \\\"(type1,type2,...)\\\".\\n\\\"\\\"\\\"\\nfunction _get_canonical_type(abi_type_str::String)::String\\n    # This is a simplified version. A full version handles all aliases and tuple structures.\\n    # Basic canonical types for Uniswap interactions\\n    type_map = Dict(\\n        \\\"uint\\\" => \\\"uint256\\\",\\n        \\\"int\\\" => \\\"int256\\\",\\n        \\\"byte\\\" => \\\"bytes1\\\",\\n        \\\"address\\\" => \\\"address\\\",\\n        \\\"bool\\\" => \\\"bool\\\",\\n        \\\"string\\\" => \\\"string\\\", # dynamic\\n        \\\"bytes\\\" => \\\"bytes\\\"   # dynamic\\n    )\\n    # Handle array types like address[] -> address[] (already canonical for this purpose)\\n    # and uint256[] etc.\\n    if endswith(abi_type_str, \\\"[]\\\")\\n        base_type = replace(abi_type_str, \\\"[]\\\" => \\\"\\\")\\n        return get(type_map, base_type, base_type) * \\\"[]\\\"\\n    end\\n    return get(type_map, abi_type_str, abi_type_str) # Assume already canonical if not in map\\nend\\n\\n\\n\\\"\\\"\\\"\\n    _abi_encode_static_value(value::Any, abi_type_str::String)::String\\n\\nEncodes a single static ABI type value to its 32-byte hex representation.\\n\\\"\\\"\\\"\\nfunction _abi_encode_static_value(value::Any, abi_type_str::String)::String\\n    canonical_type = _get_canonical_type(abi_type_str)\\n\\n    if canonical_type == \\\"address\\\" && isa(value, String) && startswith(value, \\\"0x\\\") && length(value) == 42\\n        return lpad(value[3:end], 64, '0')\\n    elseif (startswith(canonical_type, \\\"uint\\\") || startswith(canonical_type, \\\"int\\\")) && isa(value, Integer)\\n        bits_str = match(r\\\"(u?int)(\\\\d*)\\\", canonical_type)\\n        bits = isempty(bits_str.captures[2]) ? 256 : parse(Int, bits_str.captures[2])\\n        \\n        val_big = BigInt(value)\\n        if val_big < 0 && startswith(canonical_type, \\\"uint\\\")\\n            error(\\\"Cannot encode negative value \\$value for unsigned type \\$canonical_type\\\")\\n        end\\n        # Handle two's complement for negative signed integers\\n        if startswith(canonical_type, \\\"int\\\") && val_big < 0\\n            val_big = (BigInt(1) << bits) + val_big \\n        end\\n        hex_val = string(val_big, base=16)\\n        if length(hex_val) > div(bits, 4)\\n            error(\\\"Value \\$value too large for type \\$canonical_type (max \\$bits bits)\\\")\\n        end\\n        return lpad(hex_val, 64, '0')\\n    elseif canonical_type == \\\"bool\\\" && isa(value, Bool)\\n        return lpad(value ? \\\"1\\\" : \\\"0\\\", 64, '0')\\n    elseif startswith(canonical_type, \\\"bytes\\\") && !endswith(canonical_type, \\\"[]\\\") # bytes1..bytes32\\n        len_match = match(r\\\"bytes(\\\\d+)\\\", canonical_type)\\n        if !isnothing(len_match) && isa(value, Vector{UInt8})\\n            num_bytes = parse(Int, len_match.captures[1])\\n            if length(value) > num_bytes error(\\\"Data for bytes\\$num_bytes is too long: \\$(length(value)) bytes\\\") end\\n            return rpad(bytes2hex(value), 64, '0') # bytesN are left-aligned\\n        else\\n            error(\\\"Invalid value for bytesN type '\\$canonical_type' or value type '\\$(typeof(value))'. Expected Vector{UInt8}.\\\")\\n        end\\n    else\\n        error(\\\"Unsupported static ABI type '\\$canonical_type' or value type '\\$(typeof(value))' for _abi_encode_static_value.\\\")\\n    end\\nend\\n\\n\\\"\\\"\\\"\\n    _abi_encode_dynamic_value(value::Any, abi_type_str::String)::String\\n\\nEncodes the data part of a dynamic ABI type (e.g., string, bytes, T[]).\\nReturns the hex string of (length + data_padded_to_32_bytes).\\n\\\"\\\"\\\"\\nfunction _abi_encode_dynamic_value(value::Any, abi_type_str::String)::String\\n    canonical_type = _get_canonical_type(abi_type_str)\\n\\n    if (canonical_type == \\\"string\\\" && isa(value, String)) || (canonical_type == \\\"bytes\\\" && isa(value, Vector{UInt8}))\\n        data_bytes = isa(value, String) ? Vector{UInt8}(value) : value\\n        len_hex = lpad(string(length(data_bytes), base=16), 64, '0')\\n        data_hex = bytes2hex(data_bytes)\\n        # Pad data_hex to a multiple of 64 hex characters (32 bytes)\\n        padded_data_hex = rpad(data_hex, ceil(Int, length(data_hex) / 64) * 64, '0')\\n        return len_hex * padded_data_hex\\n    elseif endswith(canonical_type, \\\"[]\\\") && isa(value, AbstractVector) # Dynamic array of static types\\n        element_type_str = replace(canonical_type, \\\"[]\\\" => \\\"\\\")\\n        \\n        # Check if the element type is itself dynamic (e.g. string, bytes, another_array[], or a dynamic tuple)\\n        is_element_type_dynamic = false\\n        if element_type_str == \\\"string\\\" || element_type_str == \\\"bytes\\\" || endswith(element_type_str, \\\"[]\\\")\\n            is_element_type_dynamic = true\\n        elseif startswith(element_type_str, \\\"(\\\") && endswith(element_type_str, \\\")\\\") # Element is a tuple\\n            # Check if this tuple type is dynamic\\n            temp_element_types_str_content = element_type_str[2:end-1]\\n            temp_element_type_strs_tuple = []\\n            balance_tuple = 0; current_type_tuple_temp = \\\"\\\"\\n            for char_tt in temp_element_types_str_content\\n                if char_tt == '(' balance_tuple +=1 elseif char_tt == ')' balance_tuple -=1 end\\n                if char_tt == ',' && balance_tuple == 0\\n                    push!(temp_element_type_strs_tuple, strip(current_type_tuple_temp)); current_type_tuple_temp = \\\"\\\"\\n                else current_type_tuple_temp *= char_tt end\\n            end\\n            push!(temp_element_type_strs_tuple, strip(current_type_tuple_temp))\\n            for elem_type_str_check_tuple in temp_element_type_strs_tuple\\n                canonical_elem_type_check_tuple = _get_canonical_type(strip(elem_type_str_check_tuple))\\n                if canonical_elem_type_check_tuple == \\\"string\\\" || canonical_elem_type_check_tuple == \\\"bytes\\\" || endswith(canonical_elem_type_check_tuple, \\\"[]\\\") ||\\n                   (startswith(canonical_elem_type_check_tuple, \\\"(\\\") && occursin(r\\\"string|bytes|\\\\[\\\\]\\\", canonical_elem_type_check_tuple))\\n                    is_element_type_dynamic = true; break\\n                end\\n            end\\n        end\\n\\n        if is_element_type_dynamic\\n            # Array of dynamic types (e.g., string[], bytes[], MyDynamicStruct[])\\n            # This is complex: head contains offsets to each element's data in the tail.\\n            @error \\\"Encoding arrays of dynamic types (e.g., string[], bytes[][], or arrays of dynamic structs) is NOT YET FULLY SUPPORTED and may produce incorrect results. Type: \\$canonical_type\\\"\\n            # Placeholder logic: encode length, then try to encode each dynamic element's data sequentially.\\n            # This will be incorrect for offsets. A proper implementation needs to calculate all tail sizes first.\\n            len_hex = lpad(string(length(value), base=16), 64, '0')\\n            \\n            # This part needs a complete rewrite for arrays of dynamic types.\\n            # It should build a head part (offsets) and a tail part (actual data of dynamic elements).\\n            # For now, this will likely be incorrect.\\n            elements_data_hex = \\\"\\\"\\n            # This is a conceptual placeholder.\\n            # Each `elem` here is dynamic. Its encoding would be its own data block.\\n            # The main array's data part should contain *offsets* to these blocks.\\n            # current_offset_for_array_elements = length(value) * 32 # bytes, after all offset words\\n            # temp_array_head_parts = []\\n            # temp_array_tail_parts = []\\n            # for elem_dyn in value\\n            #     push!(temp_array_head_parts, lpad(string(current_offset_for_array_elements, base=16), 64, '0'))\\n            #     encoded_elem_dyn_data = _abi_encode_dynamic_value(elem_dyn, element_type_str) # This recursive call is problematic if not careful with context\\n            #     push!(temp_array_tail_parts, encoded_elem_dyn_data)\\n            #     current_offset_for_array_elements += div(length(encoded_elem_dyn_data),2) # This is length of data, not just one word\\n            # end\\n            # elements_hex = join(temp_array_head_parts) * join(temp_array_tail_parts)\\n            # The above is still not quite right for the general case of _abi_encode_dynamic_value.\\n            # This function is meant to return the *data block* for one dynamic item.\\n            # If that item is an array of dynamic things, its data block is (length, offset1, offset2, ..., data1, data2, ...).\\n\\n            # Array of dynamic types (e.g., string[], bytes[], MyDynamicStruct[])\\n            len_hex = lpad(string(length(value), base=16), 64, '0')\\n            \\n            # Head part of the array data will contain offsets to each dynamic element.\\n            # Tail part will contain the actual data of each dynamic element.\\n            array_head_parts_hex = String[] # Will store offsets\\n            array_tail_parts_hex = String[] # Will store encoded data of dynamic elements\\n            \\n            # The first offset is relative to the start of the array's data block (i.e., after len_hex).\\n            # This offset points to the start of the first dynamic element's data, which comes *after* all the offset words.\\n            # Number of offset words = number of elements in the array.\\n            current_offset_in_tail_bytes = length(value) * 32 \\n\\n            for elem_val in value\\n                push!(array_head_parts_hex, lpad(string(current_offset_in_tail_bytes, base=16), 64, '0'))\\n                \\n                # Now encode the dynamic element itself.\\n                # If element_type_str is \\\"string\\\" or \\\"bytes\\\", _abi_encode_dynamic_value handles it.\\n                # If element_type_str is a dynamic tuple like \\\"(uint,string)\\\", we need a robust way to encode it.\\n                local encoded_elem_data::String\\n                if element_type_str == \\\"string\\\" || element_type_str == \\\"bytes\\\"\\n                    # This is a direct call for simple dynamic types (string, bytes).\\n                    # It returns (length + data_padded).\\n                    encoded_elem_data = _abi_encode_dynamic_value(elem_val, element_type_str)\\n                elseif startswith(element_type_str, \\\"(\\\") && endswith(element_type_str, \\\")\\\") # Element is a dynamic tuple\\n                    # This is the complex case: (uint,string)[]\\n                    # We need a function to encode the *data* of one dynamic tuple.\\n                    # This function would itself handle internal head/tail for that tuple.\\n                    # Let's call a conceptual _abi_encode_one_dynamic_tuple_data\\n                    # For now, this is a major point of complexity not fully implemented.\\n                    @error \\\"Encoding for array element of dynamic tuple type '\\$element_type_str' is complex and likely incomplete/incorrect.\\\"\\n                    # Placeholder: try to encode its parts sequentially, which is wrong for internal dynamic parts.\\n                    # This needs a recursive call to a full tuple encoder.\\n                    # This is a placeholder and will likely be incorrect for complex dynamic tuples.\\n                    # It should call a function that returns the complete encoded block for the tuple.\\n                    # For now, let's assume a simplified (and likely incorrect for nested dynamics) encoding.\\n                    # This part needs a dedicated recursive tuple encoder.\\n                    # For the purpose of this step, we'll just error out or return a placeholder.\\n                    # error(\\\"Full encoding of arrays of dynamic tuples like '\\$canonical_type' is not yet implemented.\\\")\\n                    # Let's try a simplified concatenation, knowing it's limited:\\n                    temp_dyn_tuple_element_types_str_content = element_type_str[2:end-1]\\n                    temp_dyn_tuple_element_type_strs = []\\n                    balance_dtt = 0; current_type_dtt_temp = \\\"\\\"\\n                    for char_dtt in temp_dyn_tuple_element_types_str_content\\n                        if char_dtt == '(' balance_dtt +=1 elseif char_dtt == ')' balance_dtt -=1 end\\n                        if char_dtt == ',' && balance_dtt == 0\\n                            push!(temp_dyn_tuple_element_type_strs, strip(current_type_dtt_temp)); current_type_dtt_temp = \\\"\\\"\\n                        else current_type_dtt_temp *= char_dtt end\\n                    end\\n                    push!(temp_dyn_tuple_element_type_strs, strip(current_type_dtt_temp))\\n\\n                    # This is where _abi_encode_one_dynamic_tuple_data would be called.\\n                    # It would return the complete encoded block for this one tuple.\\n                    # For now, we'll use a simplified, likely incorrect approach for demonstration.\\n                    # This needs a proper recursive encoder for dynamic tuples.\\n                    # The output of this should be the *entire data block* for the tuple.\\n                    # For example, for (uint256, string), it would be (static_uint_val, offset_to_string_data, string_len, string_data_padded).\\n                    # This is too complex to correctly implement in this single step without a full recursive encoder.\\n                    # We will mark this as a known major limitation.\\n                    @warn \\\"Simplified encoding for elements of type '\\$element_type_str' in an array. May be incorrect for nested dynamic parts.\\\"\\n                    encoded_elem_data = \\\"\\\" # Placeholder for the dynamic tuple's data block\\n                    # This loop is a naive attempt and incorrect for dynamic tuples with internal dynamic parts.\\n                    # It should be replaced by a call to a recursive tuple encoder.\\n                    # For (uint, string), the uint is static, string is dynamic.\\n                    # The tuple's encoding would be: uint_val (32 bytes) + offset_to_string (32 bytes) + string_len (32 bytes) + string_data_padded.\\n                    # This is what _abi_encode_one_dynamic_tuple_data should produce.\\n                    # For now, we cannot correctly form `encoded_elem_data` here for dynamic tuples.\\n                    # The original error for string[] or bytes[] was more direct.\\n                    # Let's reinstate an error for arrays of dynamic tuples for now.\\n                     error(\\\"Encoding arrays of dynamic tuples (e.g. (uint,string)[]) is not yet fully supported. Type: \\$canonical_type\\\")\\n\\n                elseif endswith(element_type_str, \\\"[]\\\") # Array of arrays (e.g. uint[][])\\n                     error(\\\"Encoding multi-dimensional arrays or arrays of arrays (e.g., uint[][], string[][]) is not supported by this simplified encoder. Type: \\$canonical_type\\\")\\n                else\\n                    # Should not happen if is_element_type_dynamic was determined correctly\\n                    error(\\\"Unexpected dynamic element type in array: \\$element_type_str\\\")\\n                end\\n                \\n                push!(array_tail_parts_hex, encoded_elem_data)\\n                current_offset_in_tail_bytes += div(length(encoded_elem_data), 2) # Add length of this element's data block\\n            end\\n            return len_hex * join(array_head_parts_hex) * join(array_tail_parts_hex)\\n\\n        else # Array of static types (including static tuples)\\n            len_hex = lpad(string(length(value), base=16), 64, '0')\\n            # _abi_encode_static_value now handles static tuples correctly.\\n            elements_hex = join([_abi_encode_static_value(elem, element_type_str) for elem in value])\\n            return len_hex * elements_hex\\n        end\\n    else\\n        error(\\\"Unsupported dynamic ABI type '\\$canonical_type' or value type '\\$(typeof(value))' for _abi_encode_dynamic_value.\\\")\\n    end\\nend\\n\\n\\n\\\"\\\"\\\"\\nEncodes function arguments for an EVM contract call.\\n`function_signature_str` e.g., \\\"transfer(address,uint256)\\\" (canonical types)\\n`args_with_types` e.g., [(\\\"0x123...\\\", \\\"address\\\"), (100, \\\"uint256\\\")]\\n\\n**Current known limitations for `encode_function_call_abi`:**\\n- Does not fully support encoding of tuples/structs that themselves contain dynamic types.\\n  The offset calculation for multiple dynamic elements within a tuple is simplified and may be incorrect.\\n- Arrays of dynamic types (e.g., `string[]`) are explicitly not supported.\\n- Deeply nested structures may not be handled correctly.\\n\\\"\\\"\\\"\\nfunction encode_function_call_abi(function_signature_str::String, args_with_types::Vector{Tuple{Any, String}})::String\\n    # @warn \\\"\\\"\\\"encode_function_call_abi: This implementation is improved to handle static tuples (structs)\\n    #          and basic dynamic types, but has limitations for complex nested dynamic types (see notes above). \\n    #          Use with caution and test thoroughly for your specific ABI.\\\"\\\"\\\"\\n    \\n    sig_bytes = Vector{UInt8}(function_signature_str)\\n    hash_bytes = SHA.keccak256(sig_bytes)\\n    selector = bytes2hex(hash_bytes[1:4])\\n    \\n    head_parts_hex = String[]\\n    tail_parts_hex = String[]\\n    \\n    # Calculate initial offset for dynamic data: number of args * 32 bytes\\n    # This is the offset from the beginning of the arguments block (after selector)\\n    current_dynamic_offset_bytes = length(args_with_types) * 32 \\n\\n    # First pass: encode static parts and offsets for dynamic parts\\n    for (arg_val, arg_type_str) in args_with_types\\n        canonical_arg_type = _get_canonical_type(arg_type_str)\\n        is_dynamic = canonical_arg_type == \\\"string\\\" || canonical_arg_type == \\\"bytes\\\" || endswith(canonical_arg_type, \\\"[]\\\")\\n\\n        if is_dynamic\\n            # For dynamic types, head part is the offset to its data in the tail\\n            push!(head_parts_hex, lpad(string(current_dynamic_offset_bytes, base=16), 64, '0'))\\n            \\n            encoded_dynamic_data = _abi_encode_dynamic_value(arg_val, canonical_arg_type)\\n            push!(tail_parts_hex, encoded_dynamic_data)\\n            current_dynamic_offset_bytes += div(length(encoded_dynamic_data), 2) # Length of data part only\\n\\n        elseif startswith(canonical_arg_type, \\\"(\\\") && endswith(canonical_arg_type, \\\")\\\") # Tuple/Struct as an argument\\n            # This is where the logic for handling tuples (static or dynamic) as arguments goes.\\n            # A static tuple is encoded in place. A dynamic tuple has its offset encoded in place,\\n            # and its actual content (which itself might have head/tail parts) goes into the tail.\\n\\n            # For now, we assume _abi_encode_static_value can handle *static* tuples.\\n            # If a tuple is dynamic (contains dynamic members), it needs special handling here.\\n            # This simplified encoder might not correctly handle dynamic tuples as direct arguments yet.\\n            # The check for is_tuple_dynamic was inside the tuple handling block.\\n            # Let's refine this:\\n            \\n            # Determine if the tuple itself is dynamic\\n            is_tuple_dynamic = false # Placeholder: needs proper check\\n            temp_element_types_str_content = canonical_arg_type[2:end-1]\\n            temp_element_type_strs = []\\n            balance = 0; current_type_temp = \\\"\\\"\\n            for char_t in temp_element_types_str_content\\n                if char_t == '(' balance +=1 elseif char_t == ')' balance -=1 end\\n                if char_t == ',' && balance == 0\\n                    push!(temp_element_type_strs, strip(current_type_temp)); current_type_temp = \\\"\\\"\\n                else current_type_temp *= char_t end\\n            end\\n            push!(temp_element_type_strs, strip(current_type_temp))\\n\\n            for elem_type_str_check in temp_element_type_strs\\n                canonical_elem_type_check = _get_canonical_type(strip(elem_type_str_check))\\n                if canonical_elem_type_check == \\\"string\\\" || canonical_elem_type_check == \\\"bytes\\\" || endswith(canonical_elem_type_check, \\\"[]\\\") ||\\n                   (startswith(canonical_elem_type_check, \\\"(\\\") && occursin(r\\\"string|bytes|\\\\[\\\\]\\\", canonical_elem_type_check)) # Heuristic for nested dynamic tuple\\n                    is_tuple_dynamic = true\\n                    break\\n                end\\n            end\\n\\n            if is_tuple_dynamic\\n                # Dynamic tuple: encode offset in head, actual tuple data in tail.\\n                # This is the complex case requiring recursive encoding with offset management.\\n                @error \\\"Encoding of dynamic tuples/structs as direct function arguments is NOT YET FULLY SUPPORTED and may be incorrect. Arg type: \\$canonical_arg_type\\\"\\n                # Placeholder: push offset, and a (likely incorrect) concatenation for tail.\\n                push!(head_parts_hex, lpad(string(current_dynamic_offset_bytes, base=16), 64, '0'))\\n                \\n                # This is where a recursive call to a full tuple encoder would go.\\n                # For now, it will likely fail or produce wrong results for complex dynamic tuples.\\n                # Let's try to use _abi_encode_static_value which now handles static tuples,\\n                # but it will error if it finds dynamic elements inside what it expects to be a static tuple.\\n                # This highlights the need for a proper _abi_encode_tuple_value that handles internal dynamics.\\n                # For now, this path for dynamic tuples as arguments is problematic.\\n                # We'll let it attempt with _abi_encode_static_value, which will error if it's truly dynamic.\\n                # A better approach would be a dedicated _abi_encode_tuple_data function.\\n                \\n                # --- Placeholder for dynamic tuple encoding ---\\n                # This part needs a robust recursive encoder.\\n                # The current _abi_encode_static_value is for *static* tuples.\\n                # If we pass a dynamic tuple type string to it, it will error.\\n                # For now, we'll just try to encode it as if it were static, which is wrong\\n                # if it has dynamic members, but illustrates the point of needing a proper handler.\\n                # A truly dynamic tuple's encoding would itself have a head (for its static parts and offsets)\\n                # and a tail (for its dynamic parts' data).\\n                \\n                # This is a conceptual placeholder for what `_abi_encode_dynamic_tuple_data` would do:\\n                # encoded_dynamic_tuple_data_block = _abi_encode_tuple_recursively(arg_val, element_type_strs)\\n                # push!(tail_parts_hex, encoded_dynamic_tuple_data_block)\\n                # current_dynamic_offset_bytes += div(length(encoded_dynamic_tuple_data_block), 2)\\n                # For now, we'll let it fall through to the static type encoding, which will error if the tuple is dynamic.\\n                # This is not ideal but reflects the current limitation.\\n                # A proper solution requires a recursive tuple encoder.\\n                # Let's assume for now that if a tuple is passed as a direct argument and is_tuple_dynamic is true,\\n                # it's an unsupported complex case for this simplified encoder.\\n                # The error in _abi_encode_static_value for dynamic elements in a tuple will catch this.\\n                # So, we treat it like a static type for the head part, which means it's encoded in-place.\\n                # This is only correct if the tuple is actually static.\\n                # If is_tuple_dynamic is true, this path is problematic.\\n                # The logic for `is_tuple_dynamic` needs to correctly decide if it's placed in head or tail.\\n                # If dynamic, it's an offset in head, data in tail.\\n                # If static, it's data in head.\\n                # The current `_abi_encode_static_value` handles static tuples.\\n                # So, if `is_tuple_dynamic` is true, we need to place an offset.\\n                \\n                # Corrected logic:\\n                if is_tuple_dynamic\\n                    push!(head_parts_hex, lpad(string(current_dynamic_offset_bytes, base=16), 64, '0'))\\n                    # This is where a call to a proper recursive tuple encoder for the tail would go.\\n                    # e.g., encoded_tuple_data = _encode_tuple_data_recursively(arg_val, element_type_strs, initial_offset_within_tuple_data_block)\\n                    # For now, this remains a significant limitation.\\n                    # We'll push a placeholder or error if we try to fully implement this here.\\n                    # Let's assume for now that if a tuple is dynamic, we cannot properly encode its tail part yet.\\n                    # The `_abi_encode_dynamic_value` should be the one to handle this if the tuple is part of an array.\\n                    # If it's a direct argument, this `encode_function_call_abi` needs to manage its tail.\\n                    @error \\\"Full encoding of dynamic tuples as direct arguments is complex and not fully implemented. Arg type: \\$canonical_arg_type. Result may be incorrect.\\\"\\n                    # Fallback: attempt to encode its elements as if it were a sequence of static items for the tail, which is wrong.\\n                    temp_tail_data = \\\"\\\"\\n                    for (idx_tt, elem_val_tt) in enumerate(arg_val)\\n                        temp_tail_data *= _abi_encode_static_value(elem_val_tt, strip(temp_element_type_strs[idx_tt]))\\n                    end\\n                    push!(tail_parts_hex, temp_tail_data) # This is likely incorrect for dynamic tuples\\n                    current_dynamic_offset_bytes += div(length(temp_tail_data), 2)\\n                else # Tuple is static\\n                    push!(head_parts_hex, _abi_encode_static_value(arg_val, canonical_arg_type))\\n                end\\n\\n            end\\n        else # Simple static type\\n            push!(head_parts_hex, _abi_encode_static_value(arg_val, canonical_arg_type))\\n        end\\n    end\\n    \\n    return \\\"0x\\\" * selector * join(head_parts_hex) * join(tail_parts_hex)\\nend\\n\\n# --- ABI Decoding (Conceptual Placeholders) ---\\n\\n\\\"\\\"\\\"\\nDecodes a single 32-byte data segment from hex based on a canonical ABI type string.\\n\\\"\\\"\\\"\\nfunction _abi_decode_value(data_segment_hex::String, abi_type_str::String, full_data_hex_no_prefix::String, current_data_ptr::Ref{Int})::Any\\n    canonical_type = _get_canonical_type(abi_type_str)\\n\\n    if canonical_type == \\\"address\\\"\\n        return \\\"0x\\\" * data_segment_hex[end-39:end] # Address is last 20 bytes of the 32-byte word\\n    elseif startswith(canonical_type, \\\"uint\\\") || startswith(canonical_type, \\\"int\\\")\\n        # For uintN and intN, they are right-padded in the 32-byte word.\\n        # The parse function handles the full 32-byte hex.\\n        val = parse(BigInt, data_segment_hex, base=16)\\n        bits_match = match(r\\\"(u?int)(\\\\d*)\\\", canonical_type)\\n        bits = if !isnothing(bits_match) && !isempty(bits_match.captures[2])\\n                    parse(Int, bits_match.captures[2])\\n                 elseif canonical_type == \\\"uint\\\" || canonical_type == \\\"int\\\" # Default to 256 if no size specified\\n                    256\\n                 else # Fallback for types like uint112, uint160, int24\\n                    # Try to extract from type string directly if not matching common pattern\\n                    num_str = filter(isdigit, canonical_type)\\n                    isempty(num_str) ? 256 : parse(Int, num_str) # Default to 256 if no digits found\\n                 end\\n\\n        if startswith(canonical_type, \\\"int\\\") && val >= (BigInt(1) << (bits - 1)) # Check sign bit\\n            val -= (BigInt(1) << bits) # Convert from two's complement\\n        end\\n        return val\\n    elseif canonical_type == \\\"bool\\\"\\n        return parse(BigInt, data_segment_hex, base=16) != 0\\n    elseif startswith(canonical_type, \\\"bytes\\\") && !endswith(canonical_type, \\\"[]\\\") # bytes1..bytes32\\n        len_match = match(r\\\"bytes(\\\\d+)\\\", canonical_type)\\n        if !isnothing(len_match)\\n            num_bytes = parse(Int, len_match.captures[1])\\n            # bytesN are left-padded (stored at the beginning of the 32-byte word)\\n            return hex2bytes(data_segment_hex[1 : num_bytes*2]) \\n        end\\n    # --- Dynamic Type Decoding ---\\n    elseif canonical_type == \\\"string\\\" || canonical_type == \\\"bytes\\\"\\n        # data_segment_hex contains the offset to the dynamic data part.\\n        offset_bytes = parse(Int, data_segment_hex, base=16)\\n        # Offset is in bytes from the start of the *entire data block* (data_hex_no_prefix).\\n        # Convert byte offset to character index (1-based for Julia strings).\\n        offset_char_idx = offset_bytes * 2 + 1\\n\\n        if offset_char_idx + 64 - 1 > length(full_data_hex_no_prefix)\\n            @error \\\"ABI Decoding: Offset for dynamic type \\$canonical_type points out of bounds or not enough data for length.\\\"\\n            return \\\"ERROR_DECODING_OFFSET_\\$(canonical_type)\\\"\\n        end\\n        \\n        # Read the length of the data (which is itself a uint256)\\n        len_hex = full_data_hex_no_prefix[offset_char_idx : offset_char_idx + 63]\\n        len_bytes = parse(Int, len_hex, base=16)\\n        \\n        data_start_char_idx = offset_char_idx + 64\\n        data_hex_chars_to_read = len_bytes * 2\\n\\n        if data_start_char_idx + data_hex_chars_to_read - 1 > length(full_data_hex_no_prefix)\\n            @error \\\"ABI Decoding: Dynamic type \\$canonical_type data length (\\$len_bytes bytes) exceeds available data.\\\"\\n            return \\\"ERROR_DECODING_DATA_LENGTH_\\$(canonical_type)\\\"\\n        end\\n        \\n        actual_data_hex = full_data_hex_no_prefix[data_start_char_idx : data_start_char_idx + data_hex_chars_to_read - 1]\\n        \\n        return canonical_type == \\\"string\\\" ? String(hex2bytes(actual_data_hex)) : hex2bytes(actual_data_hex)\\n\\n    elseif endswith(canonical_type, \\\"[]\\\") # Dynamic array of static types\\n        offset_bytes = parse(Int, data_segment_hex, base=16)\\n        offset_char_idx = offset_bytes * 2 + 1\\n\\n        if offset_char_idx + 64 - 1 > length(full_data_hex_no_prefix)\\n            @error \\\"ABI Decoding: Offset for dynamic array \\$canonical_type points out of bounds.\\\"\\n            return [\\\"ERROR_DECODING_ARRAY_OFFSET\\\"]\\n        end\\n\\n        len_elements = parse(Int, full_data_hex_no_prefix[offset_char_idx : offset_char_idx + 63], base=16)\\n        elements_data_start_char_idx = offset_char_idx + 64\\n        \\n        element_type_str = replace(canonical_type, \\\"[]\\\" => \\\"\\\")\\n        if element_type_str == \\\"string\\\" || element_type_str == \\\"bytes\\\" || endswith(element_type_str, \\\"[]\\\")\\n            @error \\\"Decoding arrays of dynamic types (e.g., string[], bytes[][]) is not supported by this simplified decoder.\\\"\\n            return [\\\"ERROR_ARRAY_OF_DYNAMIC_UNSUPPORTED\\\"]\\n        end\\n\\n        decoded_array_elements = Any[]\\n        current_element_char_idx = elements_data_start_char_idx\\n        for _ in 1:len_elements\\n            if current_element_char_idx + 64 -1 > length(full_data_hex_no_prefix)\\n                @error \\\"ABI Decoding: Not enough data for all elements of dynamic array \\$canonical_type.\\\"\\n                break\\n            end\\n            element_segment_hex = full_data_hex_no_prefix[current_element_char_idx : current_element_char_idx + 63]\\n            # For static elements in a dynamic array, current_data_ptr is not used by _abi_decode_value for the element itself.\\n            # The full_data_hex_no_prefix is passed in case an element *was* dynamic (though we error out above for that).\\n            push!(decoded_array_elements, _abi_decode_value(element_segment_hex, element_type_str, full_data_hex_no_prefix, current_data_ptr)) # current_data_ptr is not strictly needed here for static elements\\n            current_element_char_idx += 64\\n        end\\n        return decoded_array_elements\\n    end\\n    @warn \\\"Unsupported ABI type '\\$abi_type_str' for decoding. Returning raw hex segment.\\\"\\n    return \\\"0x\\\" * data_segment_hex\\nend\\n\\n\\\"\\\"\\\"\\nDecodes function call result data.\\n`output_abi_types` is a vector of canonical ABI type strings like [\\\"address\\\", \\\"uint256\\\"].\\n\\n**Current known limitations for `decode_function_result_abi`:**\\n- Does not support decoding of arrays of dynamic types (e.g., `string[]`).\\n- Decoding of tuples/structs containing dynamic types is not implemented/tested.\\n- Assumes a flat structure for output types; nested tuples in output are not explicitly handled.\\n\\\"\\\"\\\"\\nfunction decode_function_result_abi(result_hex::String, output_abi_types::Vector{String})::Vector{Any}\\n    # @warn \\\"\\\"\\\"decode_function_result_abi: This implementation is improved for static types and basic dynamic types/arrays.\\n    #          However, it has limitations for complex nested or dynamic structures (see notes above).\\n    #          Use with caution and test thoroughly for your specific ABI.\\\"\\\"\\\"\\n    \\n    (isempty(result_hex) || result_hex == \\\"0x\\\" || length(result_hex) < 2) && return Any[] # Allow \\\"0x\\\" for empty returns\\n    if result_hex == \\\"0x\\\" && !isempty(output_abi_types)\\n        @warn \\\"ABI decoding: Received '0x' but expected outputs \\$(output_abi_types). Returning empty array.\\\"\\n        return Any[]\\n    elseif result_hex == \\\"0x\\\" && isempty(output_abi_types)\\n        return Any[] # Valid empty return\\n    end\\n\\n    data_hex_no_prefix = result_hex[3:end]\\n    if isempty(data_hex_no_prefix) && !isempty(output_abi_types)\\n         @warn \\\"ABI decoding: Received empty data string (after 0x) but expected outputs \\$(output_abi_types). Returning empty.\\\"\\n        return Any[]\\n    elseif isempty(data_hex_no_prefix) && isempty(output_abi_types)\\n        return Any[] # Valid empty return\\n    end\\n\\n\\n    outputs = Any[]\\n    head_read_char_idx = 1 # Character index in data_hex_no_prefix for reading head slots\\n    \\n    # The start of the dynamic data section is after all head slots.\\n    # Each head slot is 32 bytes (64 hex chars).\\n    dynamic_section_start_char_idx = (length(output_abi_types) * 64) + 1\\n    current_dynamic_read_ptr = Ref(dynamic_section_start_char_idx) # Ref to pass for modification\\n\\n    for type_str in output_abi_types\\n        # Ensure there's enough data for a 32-byte head slot\\n        if head_read_char_idx + 64 - 1 > length(data_hex_no_prefix)\\n            @error \\\"ABI decoding: Not enough data left in head to decode type '\\$type_str'. Expected 32 bytes, got \\$(length(data_hex_no_prefix) - head_read_char_idx + 1) chars. Decoded \\$(length(outputs)).\\\"\\n            # This often indicates an issue with the contract call or the expected output_abi_types.\\n            break \\n        end\\n        segment_hex = data_hex_no_prefix[head_read_char_idx : head_read_char_idx + 63]\\n        \\n        # The _abi_decode_value function will handle if it's static or needs to look at dynamic part.\\n        # It will use/update current_dynamic_read_ptr if it decodes a dynamic type from its offset.\\n        # Note: The current _abi_decode_value for dynamic types is still a placeholder.\\n        decoded_val = _abi_decode_value(segment_hex, type_str, data_hex_no_prefix, current_dynamic_read_ptr)\\n        push!(outputs, decoded_val)\\n        \\n        head_read_char_idx += 64 # Move to the next 32-byte slot in the head\\n    end\\n    return outputs\\nend\\n\\n\\n# ===== Ethereum RPC Method Wrappers =====\\n# These use the _make_generic_rpc_request from the parent Blockchain module.\\n\\nfunction call_contract_evm(provider::EthereumProvider, contract_address::String, data::String; block::String=\\\"latest\\\")::String\\n    if !provider.connection_dict[\\\"connected\\\"] error(\\\"Provider not connected.\\\") end\\n    params = [Dict(\\\"to\\\" => contract_address, \\\"data\\\" => data), block]\\n    # Assumes _make_generic_rpc_request is available from parent Blockchain module\\n    return Main.Blockchain._make_generic_rpc_request(provider.config.rpc_url, \\\"eth_call\\\", params)\\nend\\n\\nfunction get_nonce_evm(provider::EthereumProvider, address::String; block::String=\\\"latest\\\")::Int\\n    if !provider.connection_dict[\\\"connected\\\"] error(\\\"Provider not connected.\\\") end\\n    hex_nonce = Main.Blockchain._make_generic_rpc_request(provider.config.rpc_url, \\\"eth_getTransactionCount\\\", [address, block])\\n    return parse(Int, hex_nonce[3:end], base=16)\\nend\\n\\nfunction estimate_gas_evm(provider::EthereumProvider, tx_params::Dict)::Int\\n    # tx_params should include: from, to, value (optional), data (optional)\\n    if !provider.connection_dict[\\\"connected\\\"] error(\\\"Provider not connected.\\\") end\\n    hex_gas = Main.Blockchain._make_generic_rpc_request(provider.config.rpc_url, \\\"eth_estimateGas\\\", [tx_params])\\n    return parse(Int, hex_gas[3:end], base=16)\\nend\\n\\n# get_balance_evm, send_transaction_evm, etc., would also be implemented here,\\n# potentially calling _make_generic_rpc_request or more specific logic.\\n# They might also use functions from Blockchain.jl if those are sufficiently generic\\n# and just need the connection dictionary.\\n\\n# Example:\\nfunction get_balance_evm(provider::EthereumProvider, address::String; block::String=\\\"latest\\\")::Float64\\n    if !provider.connection_dict[\\\"connected\\\"] error(\\\"Provider not connected.\\\") end\\n    # This can directly use the generic function if it's suitable\\n    return Main.Blockchain.get_balance_generic(address, provider.connection_dict)\\nend\\n\\n# Note: Functions like send_transaction_evm would involve signing, which is complex\\n# and requires secure private key management, not handled in this illustrative client.\\n\\n@info \\\"EthereumClient.jl loaded.\\\"\\n\\nend # module EthereumClient\\n\", 0, \"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\src\\\\blockchain\\\\EthereumClient.jl\", 1, [1, 5, 64, 65, 139, 210, 250, 254, 276, 277, 327, 414, 491, 580, 674, 675, 741, 859, 898, 984, 1046, 1047, 1051, 1070, 1071, 1113, 1192, 1265, 1269, 1291, 1311, 1329, 1433, 1460, 1506, 1531, 1536, 1566, 1591, 1648, 1690, 1745, 1779, 1785, 1876, 1884, 1888, 1889, 1893, 1914, 1915, 1975, 2050, 2054, 2078, 2147, 2233, 2234, 2323, 2364, 2448, 2460, 2560, 2617, 2679, 2737, 2852, 2929, 2942, 3069, 3081, 3179, 3240, 3363, 3375, 3435, 3466, 3505, 3551, 3625, 3668, 3749, 3791, 3803, 3857, 3858, 3912, 4076, 4088, 4089, 4119, 4167, 4225, 4288, 4357, 4574, 4781, 4797, 4916, 4928, 5016, 5112, 5218, 5287, 5319, 5328, 5454, 5462, 5466, 5467, 5533, 5634, 5639, 5668, 5694, 5721, 5766, 5821, 5853, 5859, 5864, 5932, 6015, 6068, 6112, 6249, 6254, 6286, 6372, 6380, 6385, 6433, 6437, 6438, 6439, 6470, 6471, 6574, 6697, 6698, 6779, 6816, 6897, 6899, 6924, 6997, 7061, 7134, 7222, 7224, 7293, 7395, 7454, 7538, 7584, 7674, 7676, 7762, 7834, 7836, 7915, 7984, 8070, 8150, 8211, 8213, 8294, 8295, 8330, 8331, 8354, 8355, 8359, 8413, 8414, 8486, 8551, 8598, 8602, 8661, 8754, 8807, 8828, 8857, 8884, 8912, 8944, 8970, 9010, 9049, 9055, 9145, 9170, 9206, 9260, 9318, 9326, 9420, 9424, 9425, 9426, 9430, 9501, 9502, 9576, 9580, 9656, 9711, 9712, 9819, 9862, 9970, 10028, 10114, 10123, 10155, 10216, 10307, 10319, 10382, 10442, 10495, 10507, 10550, 10592, 10678, 10690, 10728, 10784, 10832, 10932, 10989, 11051, 11109, 11224, 11301, 11314, 11441, 11453, 11462, 11588, 11596, 11600, 11601, 11605, 11677, 11678, 11750, 11812, 11816, 11893, 11948, 11949, 12067, 12138, 12207, 12248, 12317, 12402, 12443, 12547, 12610, 12619, 12731, 12771, 12878, 12921, 13026, 13076, 13147, 13193, 13253, 13311, 13407, 13463, 13581, 13641, 13657, 13737, 13811, 13915, 14078, 14215, 14273, 14293, 14309, 14321, 14322, 14357, 14439, 14528, 14724, 14833, 14948, 15016, 15029, 15107, 15210, 15264, 15299, 15347, 15432, 15515, 15616, 15657, 15698, 15734, 15848, 16009, 16079, 16215, 16233, 16320, 16420, 16506, 16634, 16635, 16717, 16785, 16798, 16886, 16964, 17029, 17119, 17132, 17237, 17362, 17434, 17497, 17498, 17532, 17638, 17655, 17712, 17812, 17926, 17974, 18053, 18139, 18196, 18290, 18411, 18475, 18559, 18650, 18731, 18821, 18963, 19079, 19154, 19255, 19358, 19468, 19543, 19641, 19761, 19843, 19932, 19990, 20054, 20131, 20233, 20296, 20422, 20489, 20513, 20603, 20604, 20692, 20777, 20877, 20957, 21047, 21191, 21310, 21379, 21524, 21616, 21729, 21813, 21894, 22043, 22129, 22230, 22312, 22397, 22534, 22535, 22625, 22805, 22826, 22918, 23007, 23027, 23044, 23107, 23231, 23247, 23332, 23333, 23396, 23464, 23540, 23642, 23684, 23696, 23705, 23833, 23841, 23845, 23846, 23847, 23851, 23904, 23981, 24049, 24050, 24112, 24203, 24309, 24384, 24441, 24445, 24564, 24671, 24784, 24862, 24867, 24921, 24963, 25005, 25010, 25040, 25070, 25075, 25150, 25234, 25299, 25300, 25368, 25419, 25482, 25605, 25606, 25628, 25709, 25805, 25818, 25908, 25964, 26072, 26073, 26191, 26288, 26387, 26486, 26487, 26573, 26669, 26774, 26856, 26889, 26902, 26957, 27028, 27101, 27141, 27189, 27246, 27328, 27377, 27477, 27530, 27546, 27614, 27615, 27677, 27769, 27914, 28076, 28120, 28146, 28166, 28182, 28183, 28215, 28298, 28394, 28562, 28655, 28755, 28772, 28855, 28955, 29048, 29158, 29270, 29355, 29465, 29555, 29572, 29637, 29699, 29778, 29857, 29949, 30049, 30160, 30220, 30237, 30340, 30451, 30525, 30624, 30748, 30821, 30893, 31009, 31089, 31194, 31301, 31373, 31446, 31555, 31623, 31671, 31751, 31832, 31849, 31884, 31920, 32024, 32126, 32274, 32344, 32440, 32556, 32677, 32784, 32959, 33093, 33133, 33201, 33320, 33344, 33448, 33531, 33570, 33667, 33687, 33688, 33704, 33738, 33827, 33839, 33847, 33852, 33925, 33929, 33930, 33979, 33980, 33984, 34069, 34073, 34214, 34269, 34270, 34305, 34403, 34486, 34559, 34618, 34673, 34733, 34810, 34865, 34979, 35003, 35075, 35169, 35231, 35332, 35353, 35354, 35452, 35523, 35535, 35554, 35590, 35651, 35751, 35808, 35841, 35899, 35982, 36047, 36059, 36095, 36162, 36235, 36296, 36389, 36467, 36514, 36515, 36585, 36712, 36773, 36785, 36794, 36860, 36942, 36991, 37000, 37051, 37098, 37099, 37193, 37312, 37378, 37390, 37399, 37521, 37530, 37638, 37639, 37713, 37774, 37821, 37822, 37892, 37990, 38041, 38053, 38054, 38162, 38222, 38231, 38294, 38401, 38528, 38586, 38598, 38599, 38638, 38702, 38734, 38816, 38922, 38944, 38960, 39076, 39204, 39327, 39537, 39580, 39592, 39630, 39638, 39728, 39763, 39767, 39768, 39772, 39807, 39897, 39898, 39962, 40037, 40118, 40215, 40219, 40322, 40446, 40549, 40627, 40632, 40753, 40809, 40918, 40939, 40998, 41040, 41048, 41049, 41092, 41157, 41285, 41306, 41374, 41416, 41424, 41425, 41426, 41446, 41536, 41541, 41610, 41659, 41732, 41830, 41831, 41868, 41929, 41997, 42202, 42303, 42322, 42334, 42421, 42430, 42532, 42632, 42720, 42829, 42865, 42874, 42951, 42959, 42978, 42982, 42983, 42984, 43027, 43104, 43105, 43232, 43315, 43384, 43467, 43565, 43569, 43570, 43667, 43750, 43878, 43927, 43931, 43932, 44008, 44084, 44167, 44280, 44327, 44331, 44332, 44411, 44483, 44568, 44611, 44612, 44623, 44726, 44809, 44875, 44957, 44961, 44962, 45046, 45133, 45134, 45168, 45169, 45197]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(2464, 2463, :error, \"Expected `end`\"), Base.JuliaSyntax.Diagnostic(2464, 2463, :error, \"Expected `end`\"), Base.JuliaSyntax.Diagnostic(2464, 2463, :error, \"Expected `end`\"), Base.JuliaSyntax.Diagnostic(2464, 2540, :error, \"extra tokens after end of expression\"), Base.JuliaSyntax.Diagnostic(3085, 3090, :error, \"invalid identifier\"), Base.JuliaSyntax.Diagnostic(3091, 3155, :error, \"extra tokens after end of expression\"), Base.JuliaSyntax.Diagnostic(5323, 5326, :error, \"invalid identifier\"), Base.JuliaSyntax.Diagnostic(5458, 5460, :error, \"invalid identifier\"), Base.JuliaSyntax.Diagnostic(5462, 5464, :error, \"invalid identifier\"), Base.JuliaSyntax.Diagnostic(45169, 45171, :error, \"invalid identifier\")], :none)))))","ok":false,"file":"test_transaction_parser.jl","seconds":1.7999999523162842},{"error":"LoadError(\"C:\\\\ghost-wallet-hunter\\\\juliaos\\\\core\\\\test\\\\unit\\\\mcp\\\\test_mcp_server.jl\", 813, Some tests did not pass: 104 passed, 9 failed, 8 errored, 0 broken.)","ok":false,"file":"test_mcp_server.jl","seconds":11.866000175476074}],"mode":"smoke","categories":{"agents":{"passed":1,"total":4},"api":{"passed":0,"total":2},"analysis":{"passed":2,"total":3},"tools":{"passed":0,"total":2},"blockchain":{"passed":0,"total":3},"mcp":{"passed":0,"total":1}},"generated_at":"2025-08-15T20:11:40","wall_seconds":172.6210000514984}